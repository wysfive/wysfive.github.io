<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    集合 |  Hexo
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-java/集合" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  集合
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/18/java/%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2020-04-17T16:19:05.000Z" itemprop="datePublished">2020-04-18</time>
</a>
      
      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">2.7k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">10分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="一-Collection集合"><a href="#一-Collection集合" class="headerlink" title="一.Collection集合"></a>一.Collection集合</h1><p>​    集合是java提供的一种容器，主要用于存储多种数据。</p>
<a id="more"></a>

<hr>
<h2 id="1-1-Collection集合的概述"><a href="#1-1-Collection集合的概述" class="headerlink" title="1.1 Collection集合的概述"></a>1.1 Collection集合的概述</h2><p>​    单例集合的图：</p>
<p><img src="image/%E9%9B%86%E5%90%88.png" alt=""></p>
<hr>
<h2 id="1-2-Collection集合"><a href="#1-2-Collection集合" class="headerlink" title="1.2 Collection集合"></a>1.2 Collection集合</h2><p>​    Collection是单列集合的父接口，所以它的方法是list和set通用的，虽然实现可能有所不同，但是Collection有的方法是一定有的。</p>
<ul>
<li><p><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</p>
</li>
<li><p><code>public void clear()</code> :清空集合中所有的元素。</p>
</li>
<li><p><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</p>
</li>
<li><p><code>public boolean contains(Object obj)</code>: 判断当前集合中是否包含给定的对象。</p>
</li>
<li><p><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</p>
</li>
<li><p><code>public int size()</code>: 返回集合中元素的个数。</p>
</li>
<li><p><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中</p>
<p>这些常用方法没有难的，这里也就不具体演示了，后面分析里如果有用到就提一下。</p>
</li>
</ul>
<hr>
<h2 id="1-3-Iterator迭代器"><a href="#1-3-Iterator迭代器" class="headerlink" title="1.3 Iterator迭代器"></a>1.3 Iterator迭代器</h2><p>​    首先我们需要知道为啥要迭代器，我们知道数组中有索引，链表中可没有，它是从头结点一直向后传输来达到遍历的目的。如果每次都这么写的话太麻烦了，java就提供了迭代器来进行遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 多态的方法建立ArrayList对象的集合</span></span><br><span class="line">       Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">// 添加元素要在创建迭代器前</span></span><br><span class="line">       coll.add(<span class="string">"张三"</span>);</span><br><span class="line">       coll.add(<span class="string">"李四"</span>);</span><br><span class="line">       coll.add(<span class="string">"王五"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 迭代器也有泛型，我们需要将它同coll的泛型一致</span></span><br><span class="line">       Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(it.hasNext())&#123;<span class="comment">// 判断是否有下一个元素</span></span><br><span class="line">           String s = it.next(); <span class="comment">// 获取这个元素并将指针指向下一个数</span></span><br><span class="line">           <span class="keyword">if</span>(s.contains(<span class="string">"张三"</span>))&#123;</span><br><span class="line">               it.remove();<span class="comment">// 使用迭代器的删除方法,如果不这么做会出现并发修改异常</span></span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               System.out.println(s);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="comment">//李四 王五</span></span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">    	<span class="comment">//下面的是增强for循环，也要注意不能增删</span></span><br><span class="line">    	<span class="keyword">for</span> (String s : coll) &#123;</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125;<span class="comment">//李四 王五</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1-4-泛型"><a href="#1-4-泛型" class="headerlink" title="1.4 泛型"></a>1.4 泛型</h2><p>​    如果什么都存就会使得到时时候什么方法都不清楚能不能用。泛型的使用，使得我们在使用集合是能规定集合类型，得到了编译时期的语法检查。</p>
<ul>
<li><p><strong>泛型的类定义</strong>：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名&lt;代表泛型的变量&gt; </span>&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>  在创建对象的时候确定泛型</p>
</li>
<li><p><strong>泛型的方法方法</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>  调用方法时，确定泛型的类型</p>
</li>
<li><p><strong>泛型的通配符</strong></p>
<p>？代表可以接收任意类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型不存在继承关系 </span></span><br><span class="line">Collection&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//这种是错误的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>泛型的上限</strong>：</p>
<ul>
<li>格式： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li>意义： <code>只能接收该类型及其子类</code></li>
</ul>
</li>
<li><p><strong>泛型的下限</strong>：</p>
<ul>
<li>格式： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li>意义： <code>只能接收该类型及其父类型</code></li>
</ul>
</li>
</ul>
<hr>
<h1 id="二-List接口"><a href="#二-List接口" class="headerlink" title="二.List接口"></a>二.List接口</h1><p>​    在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过<strong>索引</strong>来访问集合中的指定元素。List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p>
<h2 id="2-1-常用方法"><a href="#2-1-常用方法" class="headerlink" title="2.1 常用方法"></a>2.1 常用方法</h2><ul>
<li><p><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</p>
</li>
<li><p><code>public E get(int index)</code>:返回集合中指定位置的元素。</p>
</li>
<li><p><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</p>
</li>
<li><p><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</p>
<p>​    这些list的常用方法，其实不难理解，需要注意的是list的方法只能在list及子类能用，set就不能用了，因为它们没有索引。</p>
</li>
</ul>
<hr>
<h2 id="2-2-ArrayList集合"><a href="#2-2-ArrayList集合" class="headerlink" title="2.2 ArrayList集合"></a>2.2 ArrayList集合</h2><p>​    arraylist的底层为数组，有查询快，增删慢的特点。    </p>
<p>Arraylist的扩容原理源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList的容量初始设置为10个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数minCapacity代表着size+1</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">		<span class="comment">//记录原来的长度</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">// 下面的语句为判空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        	<span class="comment">// 下面的语句主要的是第一个参数和第三个参数相加。</span></span><br><span class="line">        	<span class="comment">// 第二个参数是避免第三个参数为0，这样就不会添加数组的长度</span></span><br><span class="line">            <span class="keyword">int</span> newCapacity = ArraysSupport.newLength(oldCapacity,</span><br><span class="line">            		<span class="comment">// 为1</span></span><br><span class="line">                    minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span></span><br><span class="line">                    <span class="comment">// oldCapacity左移一位，空位补0，作为平常的添加的长度</span></span><br><span class="line">                    oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">/* preferred growth */</span>);</span><br><span class="line">            <span class="comment">// 以新的长度创建一个数组并作为返回值</span></span><br><span class="line">            <span class="keyword">return</span> elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 如果为空，返回初始或设置的更小长度的数组</span></span><br><span class="line">            <span class="keyword">return</span> elementData = <span class="keyword">new</span> Object[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 其实只要oldCapacity大于等于2，第三个参数都至少为1，不过怕就怕我们不小心设置初始长度小于2了</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将后两个参数的较大值，加上第一个参数，作为返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newLength</span><span class="params">(<span class="keyword">int</span> oldLength, <span class="keyword">int</span> minGrowth, <span class="keyword">int</span> prefGrowth)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert oldLength &gt;= 0</span></span><br><span class="line">        <span class="comment">// assert minGrowth &gt; 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> newLength = Math.max(minGrowth, prefGrowth) + oldLength;</span><br><span class="line">        <span class="keyword">if</span> (newLength - MAX_ARRAY_LENGTH &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> newLength;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hugeLength(oldLength, minGrowth);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-3-LinkedList集合"><a href="#2-3-LinkedList集合" class="headerlink" title="2.3 LinkedList集合"></a>2.3 LinkedList集合</h2><p>​    LinkedList底层是一个双向链表，有一个头指针和尾指针，有查询慢，增删快的特点。</p>
<ul>
<li>常用方法</li>
<li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li>
<li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li>
<li><code>public E getFirst()</code>:返回此列表的第一个元素。</li>
<li><code>public E getLast()</code>:返回此列表的最后一个元素。</li>
<li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li>
<li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li>
<li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li>
<li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li>
<li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li>
</ul>
<hr>
<h1 id="三-Collections类"><a href="#三-Collections类" class="headerlink" title="三.Collections类"></a>三.Collections类</h1><ul>
<li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。<h2 id="3-1-常用方法"><a href="#3-1-常用方法" class="headerlink" title="3.1 常用方法"></a>3.1 常用方法</h2></li>
</ul>
<p>  常用方法如下：</p>
<ul>
<li><p><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code>:往集合中添加一些元素。</p>
</li>
<li><p><code>public static void shuffle(List&lt;?&gt; list)</code>:打乱集合顺序。</p>
</li>
<li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p>
</li>
<li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</p>
<hr>
</li>
</ul>
<h2 id="3-2-Comparator比较器"><a href="#3-2-Comparator比较器" class="headerlink" title="3.2 Comparator比较器"></a>3.2 Comparator比较器</h2><p>​    Compare方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">参数</span><br><span class="line">         o1表示要比较的值</span><br><span class="line">         o2表示的是已经比较过的值</span><br><span class="line">     返回值</span><br><span class="line">         如果返回值是正数,就会把元素移动到后面(代表o1&gt;o2)</span><br><span class="line">         如果返回值是负数,就会把元素移动到前面(代表o1&lt;o2)</span><br><span class="line">         如果返回值是<span class="number">0</span>,就表示两个元素相同,就不移动(代表o1=o2)</span><br><span class="line">         如果是在set里，就不会添加进集合（这是set去重的原因）</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="四-Set接口"><a href="#四-Set接口" class="headerlink" title="四.Set接口"></a>四.Set接口</h1><p>​    set接口的特点：元素不可重复，元素是无序的，没有索引。</p>
<h2 id="4-1-HashSet集合"><a href="#4-1-HashSet集合" class="headerlink" title="4.1 HashSet集合"></a>4.1 HashSet集合</h2><p>HashSet的添加源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onlyIfAbsent用来控制是否能够修改值，为ture不能修改</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="comment">// 节点数组</span></span><br><span class="line">    Node&lt;K,V&gt; p; <span class="comment">// 用来记录哈希表中的值</span></span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 先对哈希表判空，如果没有数据则初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果在根据哈希值发现哈希表里没有这个数，为null了，直接添加这个节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// null代表的是下一个节点</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; </span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">// 先判断hash值是否相等，在判断键值是否相等，判断不为null</span></span><br><span class="line">        <span class="comment">// 如果为true说明键值相等。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 判断是否已经成为树了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 说明是哈希表加链表的结构</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 遍历到尾结点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果为链表长度8就树化</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在链表中遍历到了这个键值值，直接什么也不干</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 指针向后走一步</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明键值存在，</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 修改键值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回被修改的值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果size超过一定的值就要重新分配哈希</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image/hashmap.png" alt=""></p>
<hr>
<h2 id="4-2-LinkedHashSet集合"><a href="#4-2-LinkedHashSet集合" class="headerlink" title="4.2 LinkedHashSet集合"></a>4.2 LinkedHashSet集合</h2><p>​    linkedHashSet集合的特点是：    存取有序，元素不重复，没有索引。</p>
<p>​    为什么会存取有序呢，因为底层采用哈希表加链表的结构，在原本的结点上除去存储信息，左右指针外，还存着前一个和后一个结点位置信息的指针。</p>
<hr>
<h2 id="4-3-TreeSet集合"><a href="#4-3-TreeSet集合" class="headerlink" title="4.3 TreeSet集合"></a>4.3 TreeSet集合</h2><p>​    TreeSet集合的特点是：元素不重复，没有索引，会对元素进行排序</p>
<p>​    为什么会对元素进行排序呢，TreeSet中的元素必须实现 Comparable接口并重写compareTo()方法，TreeSet判断元素是否重复 、以及确定元素的顺序 靠的都是这个方法。</p>
<hr>
<h1 id="五-Map集合"><a href="#五-Map集合" class="headerlink" title="五.Map集合"></a>五.Map集合</h1><p>​    Map中的集合，元素是成对存在的。每个元素由键与值两部分组成，通过键可以找对所对应的值。Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。其中set的集合和map很像，需要记得是的重写hashCode()和equals()方法。</p>
<p>​    分别有HashMap，LinkedHashMap，TreeMap这三种常用集合</p>
<h2 id="5-1-Map的常用方法"><a href="#5-1-Map的常用方法" class="headerlink" title="5.1  Map的常用方法"></a>5.1  Map的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p>
<ul>
<li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li>
<li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li>
<li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li>
<li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
<li><code>public boolean containKey(Object key)</code>:判断该集合中是否有此键。</li>
</ul>
<hr>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/18/java/%E9%9B%86%E5%90%88/" data-id="ckdizs61r000gl0tu95vj598s"
        class="article-share-link">分享</a>
      
    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/04/21/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            多线程
          
        </div>
      </a>
    
    
      <a href="/2020/03/12/%E6%97%A5%E5%BF%97/git%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">git的使用</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: false,
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        John Doe
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <ul class="list-inline">
  <li>PV:<span id="busuanzi_value_page_pv"></span></li>
  <li>UV:<span id="busuanzi_value_site_uv"></span></li>
</ul>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    
    <aside class="sidebar">
      
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">目录</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
			onClick: (e) => {
      	document.getElementById(e.target.innerText).scrollIntoView()
      	return false;
    	}
    });
  </script>


<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  
  

  </div>
</body>

</html>