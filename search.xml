<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/06/%E6%97%A5%E5%BF%97/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>mybatis</title>
    <url>/2020/06/08/mybatis/</url>
    <content><![CDATA[<h1 id="1-ORM"><a href="#1-ORM" class="headerlink" title="1.ORM"></a>1.ORM</h1><p>​    ORM就是对象关系映射，是通过使用描述对象和数据库之间映射的元数据，<strong>将面向对象语言程序中的对象自动持久化到关系数据库中。</strong></p>
<p>​    我们会有一个类，专门用来与数据库中的数据进行对应，使我们对这个类中的操作可以直接持久化到数据库中。</p>
<p><strong>java中的对象</strong></p>
<ol>
<li>属性私有化</li>
<li>提供set/get方法</li>
<li>提供无参构造方法，为了以后我们可以使用框架反射然后创造一个实例做准备</li>
<li>对象应该提供序列化接口（不是必须），如果在缓存的话这个对象必须提供序列化接口，因为缓存还不是数据库，我们的操作需要“临时”的存到缓存中，然后可以提交。需要用到java提供的序列化接口。</li>
<li>属性使用包装类（不是必须），数据库中默认值为null，如果是int类型的默认值为0，与数据库不同，会出现许许多多麻烦。</li>
</ol>
<hr>
<h1 id="2-mybatis的介绍"><a href="#2-mybatis的介绍" class="headerlink" title="2.mybatis的介绍"></a>2.mybatis的介绍</h1><p>​    这图是在mybatis中文官网<a href="http://www.mybatis.cn/archives/706.html" target="_blank" rel="noopener">http://www.mybatis.cn/archives/706.html</a> 的找到的。</p>
<p><img src="image/mybatis.png" alt=""></p>
<ol>
<li>通过读取主配置文件来获取加载其它文件，这点不难，里面已经有全部的信息。</li>
<li>构造会话对象。首先构造会话工厂，使用了工厂设计思想，工厂对象只创建一次。创建会话对象，会话对象需要有connection的要素，在主配置文件中已经有了，sqlSession.getMapper()底层就是使用动态代理来创建一个与这个session有关的实例。</li>
<li>执行器执行，执行中已经封装好的sql语句。</li>
<li>最后是对参数集和结果集的处理。</li>
</ol>
<hr>
<h1 id="3-mybatis配置环境"><a href="#3-mybatis配置环境" class="headerlink" title="3.mybatis配置环境"></a>3.mybatis配置环境</h1><h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h2><h3 id="1-1-主配置文件"><a href="#1-1-主配置文件" class="headerlink" title="1.1 主配置文件"></a>1.1 主配置文件</h3><p>​    下面是我的idea中关于主配置文件的快捷键配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--引入配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"$properties$"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--别名设置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置到domain包下--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"$aliase$"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"$dataSource$"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注意名称是否一致--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--映射配置,配置到dao包下--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"$package$"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>$properties$ 指的是配置文件的路径</li>
<li>$aliase$ 指的是别名，通常我们配置到domain包下，这样我们的pojo包可以使用</li>
<li>$dataSource$ 指的是数据源，默认使用POOLED</li>
<li>$package$ 指的是映射的路径，通常配置到dao包下这样我们可以使用注解，需要保证xml名和接口名一致，如果是xml文件，那么我们需要路径名。</li>
</ol>
<h3 id="1-2-映射配置"><a href="#1-2-映射配置" class="headerlink" title="1.2 映射配置"></a>1.2 映射配置</h3><p>​    这是一个简单的映射配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"$XmlName$"</span>&gt;</span><br><span class="line">    &lt;select id=<span class="string">""</span> parameterType=<span class="string">"int"</span> resultType=<span class="string">""</span>&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>$XmlName$  写对应的namespace，也是就是之前的主配置文件写mappers配置。</li>
<li>id 写对应的方法</li>
<li>parameterType 写参数</li>
<li>resultType 写返回类型，也可以写resultMap，参数就是对应的resultMap</li>
</ol>
<hr>
<h2 id="2-mybatis"><a href="#2-mybatis" class="headerlink" title="2.mybatis"></a>2.mybatis</h2><h3 id="2-1-mybatis工具类"><a href="#2-1-mybatis工具类" class="headerlink" title="2.1 mybatis工具类"></a>2.1 mybatis工具类</h3><p>​    我们可以编写一个mybatis的工具类，其实主要是来看下mybatis中的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 工厂对象一个即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  SqlSessionFactory sqlSessionFactory = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123; <span class="comment">// 初始化这个工厂对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.加载文件 配置文件需要放在src的根路径下</span></span><br><span class="line">            InputStream is = Resources.getResourceAsStream(<span class="string">"sqlSessionConfig.xml"</span>);</span><br><span class="line">            <span class="comment">// 2.解析文件获得工厂对象</span></span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactory <span class="title">getSqlSessionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(SqlSession sqlSession)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 事务提交和关闭sqlSession</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-mybatis测试"><a href="#2-2-mybatis测试" class="headerlink" title="2.2 mybatis测试"></a>2.2 mybatis测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写编写接口</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再编写测试类</span></span><br><span class="line"><span class="meta">@before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.获得sqlSession对象</span></span><br><span class="line">    sqlSessionFactory = MybatisUtils.getSqlSessionFactory();</span><br><span class="line">    sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindAllTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">	UserDao userDao = sqlSession.getMapper(UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    List&lt;User&gt; userList = userDao.findAll();</span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">    	System.out.println();</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(user.getAccounts());</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//3.释放资源并提交事务</span></span><br><span class="line">	MybatisUtils.close(sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>jdbc</title>
    <url>/2020/06/08/jdbc/</url>
    <content><![CDATA[<h1 id="JDBC使用"><a href="#JDBC使用" class="headerlink" title="JDBC使用"></a>JDBC使用</h1><pre><code>JDBC规范是由sun公司定义接口，具体的实现由各大数据库厂商来实现。</code></pre><p><strong>JDBC四个核心对象</strong></p>
<ol>
<li>DriverMnager: 驱动管理器类 , 主要用来注册驱动和获取连接 </li>
<li>Connection: 数据库连接类 , 主要用来获取语句执行对象和控制事务 </li>
<li>Statement: SQL语句执行类</li>
<li>ResultSet: 查询的结果集类</li>
</ol>
<p><strong>jdbc的基本步骤</strong></p>
<ol>
<li>导入对应的驱动Jar包(就是导入包)</li>
<li>注册驱动 </li>
<li>获取连接</li>
<li>获得语句执行者 </li>
<li>执行语句</li>
<li>释放资源</li>
</ol>
<h2 id="2-注册"><a href="#2-注册" class="headerlink" title="2.注册"></a>2.注册</h2><p><img src="image/%E6%B3%A8%E5%86%8C.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.注册驱动</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-连接"><a href="#3-连接" class="headerlink" title="3.连接"></a>3.连接</h2><p>​    要想获取连接，必须有<strong>注册</strong>，数据库<strong>用户名</strong>，<strong>密码</strong>，明确使用<strong>哪个库</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.获得连接</span></span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/day04"</span>; <span class="comment">// 这个</span></span><br><span class="line">Connection connection = DriverManager.getConnection(url, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">System.out.println(connection);</span><br></pre></td></tr></table></figure>

<h2 id="4-获得语句执行者"><a href="#4-获得语句执行者" class="headerlink" title="4.获得语句执行者"></a>4.获得语句执行者</h2><p>​    简单的使用  <code>Statement statement = connection.createStatement()</code>，然后使用字符串拼接可以执行，不过有个问题<strong>SQL注入</strong>，也就是说我们的语句可以直接操作数据库。这样是不可取的，我们可以使用预编译来让数据库预先处理，然后只要传递参数即可。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编写sql语句,未知内容使用?占位</span></span><br><span class="line">String sql = <span class="string">"Select * from user where name = ? and password = ?;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prepareStatement()会先将SQL语句发送给数据库预编译</span></span><br><span class="line">PreparedStatement pstmt = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递参数</span></span><br><span class="line">pstmt.setString(<span class="number">1</span>,name);</span><br><span class="line">pstmt.setString(<span class="number">2</span>,password);</span><br></pre></td></tr></table></figure>

<h2 id="5-执行语句"><a href="#5-执行语句" class="headerlink" title="5.执行语句"></a>5.执行语句</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增删改使用执行语句</span></span><br><span class="line"><span class="keyword">int</span> update = pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询使用查询语句</span></span><br><span class="line">ResultSet rs = pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部有一个指针,只能取指针指向的那条记录       </span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123; <span class="comment">// 指针移动一行,有数据才返回true            </span></span><br><span class="line">    <span class="comment">// 取出数据 这里可以getObject()来获取           </span></span><br><span class="line">    <span class="keyword">int</span> cid = rs.getInt(<span class="string">"cid"</span>);            </span><br><span class="line">    String cname = rs.getString(<span class="string">"cname"</span>);                        </span><br><span class="line">    System.out.println(cid + <span class="string">" == "</span> + cname);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="JDBC事务和连接池"><a href="#JDBC事务和连接池" class="headerlink" title="JDBC事务和连接池"></a>JDBC事务和连接池</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h2><p>​    jdbc中默认自动开启提交事务，每条语句都会自动提交。java中实现事务使用try-catch，在<strong>try</strong>的<strong>第一行开启</strong>，在try框中的<strong>最后一行提交事务</strong>。在<strong>catch框中回滚事务</strong>。</p>
<p>​    原理就是在try中的没有异常，那么必然在最后一行使用提交，在catch框必然触发了异常，那么就回滚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">操作事务基本的原理跟之前操作cmd一样,都是开启事务,提交事务,回滚事务 </span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="number">1</span>. 代码第一行开启事务 </span><br><span class="line">	connection.setAutocommit( <span class="keyword">false</span> ) </span><br><span class="line">	<span class="number">2</span>. 代码最后一行提交事务 </span><br><span class="line">	connection.commit() </span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e )&#123;</span><br><span class="line">	<span class="number">3</span>. 发生异常回滚事务 </span><br><span class="line">	connection.rollback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-连接池"><a href="#2-连接池" class="headerlink" title="2.连接池"></a>2.连接池</h2><p>​    连接池是创建和管理数据库连接的缓存池技术，连接池中保存了一些数据的连接。这些连接是可以反复利用的。当我们使用时就从连接池中获取一个连接，关闭时就返回一个连接到连接池中。</p>
<p>​    我们以druid为例，druid是阿里巴巴公司创建的连接池技术。下面的是配置文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 驱动类名。根据url自动识别，这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) </span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver </span></span><br><span class="line"><span class="comment"># 连接数据库的url </span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/day25 </span></span><br><span class="line"><span class="comment"># 数据库的用户名 </span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root </span></span><br><span class="line"><span class="comment"># 数据库的密码 </span></span><br><span class="line"><span class="attr">password</span>=<span class="string">root </span></span><br><span class="line"><span class="comment"># 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 </span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5 </span></span><br><span class="line"><span class="comment"># 最大连接池数量 </span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10 </span></span><br><span class="line"><span class="comment"># 获取连接时最大等待时间，单位毫秒。 </span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000 </span></span><br><span class="line"><span class="comment"># 最小连接池数量 </span></span><br><span class="line"><span class="attr">minIdle</span>=<span class="string">3</span></span><br></pre></td></tr></table></figure>

<p>​    其中有连接的四要素，<strong>驱动、url、用户名、密码</strong>，初始的连接个数，最大连接数，最小连接数，最大等待时间。连接的数量是<strong>动态</strong>的，我们不想要定一个数量然后就一直使用这个数量，连接的数量是有高峰期和低峰期的，我们定完最大连接数，最小连接数就会自动的在这两个数量中变化。而最大等待时间是在最大连接数满了以后，如果有其他的连接的需求， 我们会让它在等待一会，也就是排队，然后才拒绝。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载配置文件中的配置参数        </span></span><br><span class="line">InputStream is = Demo03.class.getResourceAsStream("/druid.properties")</span><br><span class="line">Properties pp = <span class="keyword">new</span> Properties();</span><br><span class="line">pp.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接池，使用配置文件中的参数        </span></span><br><span class="line">DataSource ds = DruidDataSourceFactory.createDataSource(pp);</span><br><span class="line"><span class="comment">// 从连接池中取出连接</span></span><br><span class="line">Connection conn = ds.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用jdbc执行SQL语句 省略</span></span><br><span class="line"></span><br><span class="line">conn.close(); <span class="comment">// 将连接还回连接池中，连接池对close()方法增强</span></span><br></pre></td></tr></table></figure>







]]></content>
  </entry>
  <entry>
    <title>数据库入门</title>
    <url>/2020/06/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="一-创建数据库"><a href="#一-创建数据库" class="headerlink" title="一.创建数据库"></a>一.创建数据库</h1><h2 id="1-快速创建一个表-DDL语句"><a href="#1-快速创建一个表-DDL语句" class="headerlink" title="1.快速创建一个表(DDL语句)"></a>1.快速创建一个表(DDL语句)</h2><p>​    数据库学习需要先创建一个数据库，一个库中可以有许许多多的表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database db1; -- 创建一个数据库</span><br><span class="line">use db1; -- 使用数据库db1</span><br><span class="line">create table stu( -- 创建一个表</span><br><span class="line">	id int primary key auto_increment, -- 设置主键约束自增</span><br><span class="line">	sname varchar(32)，</span><br><span class="line">	brithday DATE,</span><br><span class="line">	class int </span><br><span class="line">);</span><br><span class="line">-- 快速创建一个结构相同的表 </span><br><span class="line">CREATE TABLE newtb LIKE stu;</span><br><span class="line"></span><br><span class="line">-- 删表</span><br><span class="line">drop table newtb;</span><br><span class="line"></span><br><span class="line">-- 查看stu结构</span><br><span class="line">DESC stu;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-增删改-DML"><a href="#2-增删改-DML" class="headerlink" title="2.增删改(DML)"></a>2.增删改(DML)</h2><h2 id="1-添加数据"><a href="#1-添加数据" class="headerlink" title="(1).添加数据"></a>(1).添加数据</h2><p><strong>INSERT INTO 表名 (字段名1, 字段名2, …) VALUES (值1, 值2, …)</strong></p>
<p>​    添加一条数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into stu (id, sname, brithday, class) value (1, &#39;张三&#39;, &#39;2020-01-01&#39;, 1);</span><br></pre></td></tr></table></figure>

<p>​    批量添加数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO stu (id, sname, brithday, class) </span><br><span class="line">VALUE (2, &#39;李四&#39;, &#39;2020-01-02&#39;, 2),</span><br><span class="line">(3, &#39;王五&#39;, &#39;2020-01-03&#39;, 2),</span><br><span class="line">(4, &#39;赵六&#39;, &#39;2020-01-04&#39;, 2),</span><br><span class="line">(5, &#39;田七&#39;, &#39;2020-01-05&#39;, 2),</span><br><span class="line">(6, &#39;王八&#39;, &#39;2020-01-06&#39;, NULL),</span><br><span class="line">(7, &#39;jojo&#39;, &#39;2020-01-07&#39;, 2);</span><br></pre></td></tr></table></figure>

<h2 id="2-修改数据"><a href="#2-修改数据" class="headerlink" title="(2).修改数据"></a>(2).修改数据</h2><p><strong>UPDATE 表名 SET 字段名=值 WHERE 字段名=值;</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE stu SET sname &#x3D; &#39;历史&#39; WHERE id &#x3D; 2;</span><br></pre></td></tr></table></figure>

<h2 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="(3).删除数据"></a>(3).删除数据</h2><p><strong>DELETE FROM 表名 WHERE 字段名=值;</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from stu where id &#x3D; 7;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二-查询数据库"><a href="#二-查询数据库" class="headerlink" title="二.查询数据库"></a>二.查询数据库</h1><h2 id="1-简单查询"><a href="#1-简单查询" class="headerlink" title="1.简单查询"></a>1.简单查询</h2><p>​    查询是一种不会修改表的操作，在日常的生活中，添加和查询是最多的。</p>
<p>​    查询数据库中，其中全部的语句都在下面有一一对应的说明，其中聚合函数与group by有关，是依据分组之后的聚合。<strong>聚合函数</strong>有5个count()，max()，min()，sum()，avg()。</p>
<p>​    数据库中是有函数使用的，不会就去菜鸟查。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct *,字段,字段的计算,聚合函数,字段 as 别名 </span><br><span class="line">from 表名</span><br><span class="line">where 条件 and 条件 or 条件</span><br><span class="line">[group by 分组的字段,分组的字段 having 分组后的条件]</span><br><span class="line">[order by 排序字段 asc升序&#x2F;desc降序,排序字段 asc升序&#x2F;desc降序]</span><br><span class="line">[limit startIndex 开始索引, pageSize 每页显示个数]</span><br></pre></td></tr></table></figure>

<p><strong>数据库关键字的执行顺序问题</strong></p>
<ol>
<li>select  表示查询</li>
<li>from 查询哪张表</li>
<li>where  进行数据的筛选</li>
<li>group by  将筛选后的数据进行分组</li>
<li>having 将分组后的数据进行筛选</li>
<li>select 字段 确定显示的字段数据</li>
<li>distinct  将显示的字段去重</li>
<li>order by 执行排序</li>
<li>limit 分页</li>
</ol>
<h2 id="2-复杂查询"><a href="#2-复杂查询" class="headerlink" title="2.复杂查询"></a>2.复杂查询</h2><h3 id="1-约束"><a href="#1-约束" class="headerlink" title="(1).约束"></a>(1).约束</h3><p>​    在数据库中，我们有时需要对我们添加的数据管理，所以我们需要添加约束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 将前面的表修改为</span><br><span class="line">create table stu( -- 创建一个表</span><br><span class="line">	id int primary key auto_increment, -- 设置主键约束自增</span><br><span class="line">	sname varchar(32) unique, -- 唯一约束</span><br><span class="line">	brithday DATE not null, -- 非空约束</span><br><span class="line">	class int -- 默认约束</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table class(</span><br><span class="line">	cid int primary key auto_increment,</span><br><span class="line">	cname varchar(32) </span><br><span class="line">);</span><br><span class="line">#添加约束: FOREIGN KEY  外键</span><br><span class="line">#alter table 从表名 add [constraint] [外键的名称] foreign key (从表的某个字段) references 主表(主表的字段)</span><br><span class="line">INSERT INTO class VALUE (NULL, &#39;一班&#39;), (NULL, &#39;二班&#39;), (NULL, &#39;三班&#39;);</span><br><span class="line">alter table stu add constraint class_stu_fk foreign key cid references stu(class);</span><br></pre></td></tr></table></figure>

<h3 id="2-复杂查询-1"><a href="#2-复杂查询-1" class="headerlink" title="(2).复杂查询"></a>(2).复杂查询</h3><h4 id="a-内连接"><a href="#a-内连接" class="headerlink" title="a.内连接"></a>a.内连接</h4><p>​    内连接就是两个集合中的相交的部分。</p>
<p><img src="image/%E5%86%85%E8%BF%9E%E6%8E%A5.png" alt="内连接"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 隐式内连接</span><br><span class="line">SELECT * FROM stu, class WHERE stu.&#96;class&#96; &#x3D; class.cid;</span><br><span class="line">-- 显式内连接:</span><br><span class="line">SELECT * FROM stu INNER JOIN class ON stu.&#96;class&#96; &#x3D; class.cid;</span><br></pre></td></tr></table></figure>

<h4 id="b-外连接"><a href="#b-外连接" class="headerlink" title="b.外连接"></a>b.外连接</h4><p>​    外连接就是在查询到某个表的全部信息外，还能查到其他表中对应的信息。</p>
<p><img src="image/%E5%A4%96%E8%BF%9E%E6%8E%A5.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 左外连接</span><br><span class="line">SELECT * FROM stu LEFT JOIN class ON stu.&#96;class&#96; &#x3D; class.&#96;cid&#96;;</span><br><span class="line">-- 右外连接</span><br><span class="line">SELECT * FROM stu RIGHT JOIN class ON stu.&#96;class&#96; &#x3D; class.&#96;cid&#96;;</span><br></pre></td></tr></table></figure>

<h4 id="c-子查询"><a href="#c-子查询" class="headerlink" title="c.子查询"></a>c.子查询</h4><p>​    数据库中有着类似嵌套查询的概念，某一个表查询出来的信息可以作为其他的查询的条件。通常来讲，如果逻辑太过于复杂我们就可以使用嵌套查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询学生班级编号大于2的班级名</span><br><span class="line">-- 班级编号大于2</span><br><span class="line">select class from stu where class &gt; 2;</span><br><span class="line">-- 查询语句</span><br><span class="line">select cname from class where cid in</span><br><span class="line">(select class from stu where class &gt; 2);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="三-事务"><a href="#三-事务" class="headerlink" title="三.事务"></a>三.事务</h1><h3 id="1-四大特性（ACID）"><a href="#1-四大特性（ACID）" class="headerlink" title="1.四大特性（ACID）"></a>1.四大特性（ACID）</h3><p>原子性: 事务将一组逻辑单元看成 一个操作 , 原子是最小单位不可再分割</p>
<p>一致性: 事务的前后 数据的应该保持一致</p>
<p>隔离性(isolation):  <strong>事务之间 彼此应该产生隔离</strong>, 隔离就会产生隔离问题 有问题就要解决</p>
<p>持久性: 事务不可逆 , 事务操作以后 不可再逆转(commit 之后 或者 rollback  事务销毁 不会再有了)</p>
<h3 id="2-解决方案-隔离级别"><a href="#2-解决方案-隔离级别" class="headerlink" title="2.解决方案(隔离级别)"></a>2.解决方案(隔离级别)</h3><p>1.读未提交: read uncommitted   : 不解决任何问题 (不可能用)</p>
<p>2.读已提交: read committed : 解决脏读问题 , 有不可重复读和虚读的问题(oracle 的默认隔离级别)</p>
<p>3.可重复读: repeatable read :  解决脏读和不可重复读问题  ,    有虚读问题  (mysql 默认的隔离级别)</p>
<p>4.串行化: serializable   :(单线程 )解决所有问题 只有一个事务 (不可能用)</p>
<p>​    mysql中实现事务的方法（以read committed为例）是将日志中的内容锁起来。例如，如果有消息其他事务要查询的话，必然是会对事务的隔离出现问题，那么我们在对这事务中有在未提交前的<strong>添加</strong>都需要锁起来，其他事务查询时会读到锁，认为没有这条sql，跳过这条语句。</p>
<h3 id="3-repeatable-read"><a href="#3-repeatable-read" class="headerlink" title="3.repeatable read"></a>3.repeatable read</h3><p>​    采用的是MVCC和next-key-lock来解决重复读的问题。</p>
<h4 id="a-MVCC"><a href="#a-MVCC" class="headerlink" title="a.MVCC"></a>a.MVCC</h4><p>​    MVCC有两种版本号，分别为系统版本号（递增的数字,开启一个事务就会增加一个数字），与事务版本号（在同一个事务中是同一个版本号）。</p>
<p>​    在innodb的表每条语句都有三列隐藏列分别为RowID，DB_TRX_ID，DB_ROLL_PTR。使用的都是<strong>版本号</strong>，如果删除没有执行就是未定义的。</p>
<p>​    创建和删除一行数据时，当前的系统版本号会作为其的版本号。如果删除的版本号大于其事务的版本号，说明已经被删除了。</p>
<p>​    查询时，只能查询到系统版本号小于或等于的事务版本号的行，如果是删除行的数据就只能读取到系统版本号大于或未定义的事务版本号的行。</p>
<p>​    对于查询操作的是基于当前的事务版本号的（快照读），对于增删改是基于当前的系统版本号的（当前读）。</p>
<p>​    这样对于大多数的操作的都可以完成。</p>
<p>​    不过还是有一个问题，事务1先开启（假设版本号为1），事务2后开启（假设版本号为2），在事务1上进行的增删改的操作都为版本号2的内容，那么对于事务2来说是可见的，也就是非隔离。</p>
<h4 id="b-next-key-lock"><a href="#b-next-key-lock" class="headerlink" title="b.next-key-lock"></a>b.next-key-lock</h4><p>​    它是由行锁（record locks）和间隙锁（gap locks）组成，即锁住其本身还锁住其索引的间隙（不可为唯一的约束，innodb会优化成行锁），</p>
]]></content>
  </entry>
  <entry>
    <title>web的三大组件</title>
    <url>/2020/06/08/javaweb/web%E7%9A%84%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="一-servlet"><a href="#一-servlet" class="headerlink" title="一.servlet"></a>一.servlet</h1><p>​    servlet是一套接口，由web服务器管理的，服务器会自动的帮我们处理底层的TCP请求和响应，获取xml或者是注解的中的信息，还有servlet是<strong>单例</strong>的，多线程时存在安全隐患，<strong>成员变量是不安全的，</strong>所以不要存储数据，而方法不是共享的，所以可以<strong>存储在局部变量</strong>中。</p>
<h2 id="1-servlet与普通java程序的区别"><a href="#1-servlet与普通java程序的区别" class="headerlink" title="1.servlet与普通java程序的区别"></a>1.servlet与普通java程序的区别</h2><ol>
<li>必须实现servlet接口 </li>
<li>必须在servlet容器（服务器）中运行 </li>
<li>servlet程序可以接收用户请求参数以及向浏览器输出数据</li>
</ol>
<h2 id="2-servlet的web-xml配置"><a href="#2-servlet的web-xml配置" class="headerlink" title="2.servlet的web.xml配置"></a>2.servlet的web.xml配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span>           <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>           <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee                        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span> <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>         </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.web.DemoServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定Servlet的创建时机，分</span></span><br><span class="line"><span class="comment">    1.第一次被访问时，创建</span></span><br><span class="line"><span class="comment">        当&lt;load-on-startup&gt;&lt;/load-on-startup&gt;值为负数是第一次被访问时创建，默认值为-1</span></span><br><span class="line"><span class="comment">    2.在服务器启动时，创建</span></span><br><span class="line"><span class="comment">        &lt;load-on-startup&gt;&lt;/load-on-startup&gt;值为0或正整数</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span><span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二-filter"><a href="#二-filter" class="headerlink" title="二.filter"></a>二.filter</h1><p>​    filter过滤器，就是在拦截路径下，先执行这一过滤器，通常用来解决登录过滤,敏感词过滤,编码问题。</p>
<h2 id="1-filter的拦截路径"><a href="#1-filter的拦截路径" class="headerlink" title="1.filter的拦截路径"></a>1.filter的拦截路径</h2><ol>
<li>具体资源路径拦截：/index.jsp    只有访问index.jsp资源时，过滤器才会被执行 </li>
<li>拦截目录：/user/* 访问/user下的所有资源时，过滤器都会被执行 </li>
<li>后缀名拦截：*.jsp 访问所有后缀名为jsp资源时 过滤器都会被执行 </li>
<li>拦截所有资源：/* 访问所有资源时过滤器会被执行 </li>
</ol>
<p><strong>注意: filter中没有缺省路径(/),</strong>servlet中有，只要找不到路径，就跳转到这个路径，整个服务器中都有这个配置。</p>
<h2 id="2-filter的web-xml配置"><a href="#2-filter的web-xml配置" class="headerlink" title="2.filter的web.xml配置"></a>2.filter的web.xml配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.itcast.web.filter.FilterDemo2<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-过滤链问题"><a href="#3-过滤链问题" class="headerlink" title="3.过滤链问题"></a>3.过滤链问题</h2><p>​    允许有多个过滤器存在,执行顺序如下:</p>
<ol>
<li>xml配置为它的配置顺序</li>
<li>如果是注解的话，那么就是按名字的顺序（也就是String排列顺序），没有写名字就是全限定类名。</li>
</ol>
<hr>
<h1 id="三-listener"><a href="#三-listener" class="headerlink" title="三.listener"></a>三.listener</h1><p>​    监听器就是监听某一事件的发生。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebListener</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletContextListenner2</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;        			System.out.println(<span class="string">"服务器启动，servletContext被创建了"</span>);       </span><br><span class="line">        ServletContext servletContext = servletContextEvent.getServletContext();    </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;        				System.out.println(<span class="string">"服务器停止，servletContext被销毁了"</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里简单的说明了是在这个容器初始化和结束时进行监听，然后执行我们的方法。</p>
]]></content>
  </entry>
  <entry>
    <title>http入门</title>
    <url>/2020/06/07/javaweb/http%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>#　一.HTTP</p>
<p>​    <strong>超文本传输协议</strong>（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。 所 有的WWW文件都必须遵守这个标准。</p>
<p>​     http请求一共分为三个部分：请求行，请求头，请求体。</p>
<p>​     http响应也分成三个部分——响应行 （状态行）、响应头、响应体。</p>
<hr>
<h1 id="二-response"><a href="#二-response" class="headerlink" title="二.response"></a>二.response</h1><p>​    response是http中有关响应的对象，其中request也是http中比较重要的对象，我把它放在域对象中。</p>
<h2 id="1-常见状态码"><a href="#1-常见状态码" class="headerlink" title="1.常见状态码"></a>1.常见状态码</h2><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td><strong>OK</strong>。请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。</td>
</tr>
<tr>
<td>302</td>
<td><strong>Move temporarily</strong>。重定向，请求的资源临时从不同的 URI响应请求。</td>
</tr>
<tr>
<td>304</td>
<td><strong>Not Modified</strong>。从缓存中读取数据，不从服务器重新获取数据。</td>
</tr>
<tr>
<td>403</td>
<td><strong>Forbidden</strong>。服务器已经理解请求，但是拒绝执行它，一般在权限不够的时候常见。</td>
</tr>
<tr>
<td>404</td>
<td><strong>Not Found</strong>。请求失败，请求所希望得到的资源未被在服务器上发现。</td>
</tr>
<tr>
<td>405</td>
<td><strong>Method Not Allowed</strong>。请求行中指定的请求方法不能被用于请求相应的资源。</td>
</tr>
<tr>
<td>500</td>
<td><strong>Internal Server Error</strong>。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-页面跳转"><a href="#2-页面跳转" class="headerlink" title="2.页面跳转"></a>2.页面跳转</h2><p>​    通常来说使用重定向还是请求转发需要看实际的需求。如果有数据，必然是使用请求转发，可是有些页面我们不想让用户使用，由于请求转发会让这个页面不会在原来的页面，也就是这个页面不会改变。</p>
<h3 id="1-重定向"><a href="#1-重定向" class="headerlink" title="(1).重定向"></a>(1).重定向</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中request.getContextPath()是指当前的项目的地址</span></span><br><span class="line"><span class="comment">// 后面写需要的跳转的地址</span></span><br><span class="line">response.sendRedirect(request.getContextPath()+<span class="string">"/emp?action=findAll"</span>);`</span><br></pre></td></tr></table></figure>

<h3 id="2-请求转发"><a href="#2-请求转发" class="headerlink" title="(2).请求转发"></a>(2).请求转发</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中不需要重新写项目的地址,该方法会帮我们找到</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">"/update.jsp"</span>).forward(request,response)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-输出内容"><a href="#3-输出内容" class="headerlink" title="3.输出内容"></a>3.输出内容</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.getWriter().print();</span><br></pre></td></tr></table></figure>

<p>​    这种输出方式还是很少使用的，不过我们有个点值得注意，就是在ajax中，输出的内容不再是在页面上，而是在<strong>回调函数的成功方法</strong>中。</p>
]]></content>
  </entry>
  <entry>
    <title>http入门</title>
    <url>/2020/06/07/http%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>#　一.HTTP</p>
<p>​    <strong>超文本传输协议</strong>（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。 所 有的WWW文件都必须遵守这个标准。</p>
<p>​     http请求一共分为三个部分：请求行，请求头，请求体。</p>
<p>​     http响应也分成三个部分——响应行 （状态行）、响应头、响应体。</p>
<hr>
<h1 id="二-response"><a href="#二-response" class="headerlink" title="二.response"></a>二.response</h1><p>​    response是http中有关响应的对象，其中request也是http中比较重要的对象，我把它放在域对象中。</p>
<h2 id="1-常见状态码"><a href="#1-常见状态码" class="headerlink" title="1.常见状态码"></a>1.常见状态码</h2><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td><strong>OK</strong>。请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。</td>
</tr>
<tr>
<td>302</td>
<td><strong>Move temporarily</strong>。重定向，请求的资源临时从不同的 URI响应请求。</td>
</tr>
<tr>
<td>304</td>
<td><strong>Not Modified</strong>。从缓存中读取数据，不从服务器重新获取数据。</td>
</tr>
<tr>
<td>403</td>
<td><strong>Forbidden</strong>。服务器已经理解请求，但是拒绝执行它，一般在权限不够的时候常见。</td>
</tr>
<tr>
<td>404</td>
<td><strong>Not Found</strong>。请求失败，请求所希望得到的资源未被在服务器上发现。</td>
</tr>
<tr>
<td>405</td>
<td><strong>Method Not Allowed</strong>。请求行中指定的请求方法不能被用于请求相应的资源。</td>
</tr>
<tr>
<td>500</td>
<td><strong>Internal Server Error</strong>。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-页面跳转"><a href="#2-页面跳转" class="headerlink" title="2.页面跳转"></a>2.页面跳转</h2><p>​    通常来说使用重定向还是请求转发需要看实际的需求。如果有数据，必然是使用请求转发，可是有些页面我们不想让用户使用，由于请求转发会让这个页面不会在原来的页面，也就是这个页面不会改变。</p>
<h3 id="1-重定向"><a href="#1-重定向" class="headerlink" title="(1).重定向"></a>(1).重定向</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中request.getContextPath()是指当前的项目的地址</span></span><br><span class="line"><span class="comment">// 后面写需要的跳转的地址</span></span><br><span class="line">response.sendRedirect(request.getContextPath()+<span class="string">"/emp?action=findAll"</span>);`</span><br></pre></td></tr></table></figure>

<h3 id="2-请求转发"><a href="#2-请求转发" class="headerlink" title="(2).请求转发"></a>(2).请求转发</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中不需要重新写项目的地址,该方法会帮我们找到</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">"/update.jsp"</span>).forward(request,response)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-输出内容"><a href="#3-输出内容" class="headerlink" title="3.输出内容"></a>3.输出内容</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.getWriter().print();</span><br></pre></td></tr></table></figure>

<p>​    这种输出方式还是很少使用的，不过我们有个点值得注意，就是在ajax中，输出的内容不再是在页面上，而是在<strong>回调函数的成功方法</strong>中。</p>
]]></content>
  </entry>
  <entry>
    <title>域对象</title>
    <url>/2020/06/07/javaweb/%E5%9F%9F%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="一-域对象"><a href="#一-域对象" class="headerlink" title="一.域对象"></a>一.域对象</h1><p>​    域对象的作用是让数据在一定范围内可以共享。</p>
<h2 id="1-域对象的api"><a href="#1-域对象的api" class="headerlink" title="1.域对象的api"></a>1.域对象的api</h2><p>​    下面的api是域对象中都有的。作用见名知意，所有的key都必然都是<strong>String</strong>。</p>
<p>setAttribute(String key , Object Value )</p>
<p>getAttribute(String key )</p>
<p>removeAttribute (String key )</p>
<h2 id="2-域对象该如何选择"><a href="#2-域对象该如何选择" class="headerlink" title="2.域对象该如何选择"></a>2.域对象该如何选择</h2><ol>
<li><p>需求优先原则</p>
<p>​    任何不能完成需求的辩解都是耍流氓，连需求都完成不了就肯定小了。</p>
</li>
<li><p>能小不大原则</p>
<p>​    域对象如果太大，那必然导致数据与数据之间可能污染，也就这个数据不然就很久不用，一用就发觉这个数据是个错误的数据。</p>
</li>
</ol>
<hr>
<h1 id="二-ServletContext"><a href="#二-ServletContext" class="headerlink" title="二.ServletContext"></a>二.ServletContext</h1><h2 id="1-作用范围"><a href="#1-作用范围" class="headerlink" title="1.作用范围"></a>1.作用范围</h2><p>​    servletContext的数据是对于整个服务器。</p>
<h2 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2.生命周期"></a>2.生命周期</h2><p>​    服务器启动时建立，服务器关闭时销毁。</p>
<h2 id="3-作用"><a href="#3-作用" class="headerlink" title="3.作用"></a>3.作用</h2><ol>
<li><p>获取web应用的初始化参数 </p>
</li>
<li><p>使用ServletContext实现请求转发</p>
<p><code>this.getServletContext().getRequestDispatcher().forward()</code></p>
</li>
</ol>
<hr>
<h1 id="三-Request"><a href="#三-Request" class="headerlink" title="三.Request"></a>三.<strong>Request</strong></h1><h2 id="1-作用范围-1"><a href="#1-作用范围-1" class="headerlink" title="1.作用范围"></a>1.作用范围</h2><p>​    一整个请求链，请求转发也是在这一条请求链中。</p>
<h2 id="2-生命周期-1"><a href="#2-生命周期-1" class="headerlink" title="2.生命周期"></a>2.生命周期</h2><p>​    在service（）方法前建立，在response时销毁。</p>
<h2 id="3-作用-1"><a href="#3-作用-1" class="headerlink" title="3.作用"></a>3.作用</h2><ol>
<li><p>request中有许多有关于本次请求的信息，比如请求类型，请求路径，浏览器的类型版本，上次请求的地址（<strong>防盗链</strong>）等等，具体可以翻看api。</p>
</li>
<li><p>获取请求中的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getParameter</span><span class="params">(String name)</span>  根据表单的name属性 获取对应的值</span></span><br><span class="line"><span class="function">String[] <span class="title">getParameterValues</span><span class="params">(String name)</span>  获取name相同的所有value 例如复选框。</span></span><br><span class="line"><span class="function">Map <span class="title">getParameterMap</span><span class="params">()</span>  请求参数名作为key，参数值作为value，封装到map中</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h1 id="四-session"><a href="#四-session" class="headerlink" title="四.session"></a>四.session</h1><h2 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1.cookie"></a>1.cookie</h2><p>​    在了解session前需要知道cookie，cookie技术用来解决http的无状态问题，无论请求多少次，服务器都会把这一次请求当做全新的请求，这样对于用户来说有些功能是极其难以实现的，所以我们需要cookie技术。</p>
<p>​    cookie技术说穿了也就是服务器会给这一次请求产生一个cookie，用来记录这次数据还是之前的请求，浏览器会对cookie保存起来。那么下一次请求时，那个服务器就会知道这些信息来自上次的请求。</p>
<h3 id="1-cookie的常用方法"><a href="#1-cookie的常用方法" class="headerlink" title="(1).cookie的常用方法"></a>(1).cookie的常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie:   </span><br><span class="line">	Cookie(String name, String value)  创建cookie对象    </span><br><span class="line">	<span class="function">String <span class="title">getName</span><span class="params">()</span>   获取cookie的名称    </span></span><br><span class="line"><span class="function">	String <span class="title">getValue</span><span class="params">()</span>  获取cookie的值    </span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String uri)</span>   设置cookie的路径——浏览器根据这个路径判断那些cookie 要发送给服务器</span></span><br><span class="line"><span class="function">	</span></span><br><span class="line"><span class="function">HttpServletResponse：    </span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">addCookie</span><span class="params">(Cookie cookie)</span>   将cookie发送给浏览器</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">HttpServletRequest：    </span></span><br><span class="line"><span class="function">	Cookie[] <span class="title">getCookies</span><span class="params">()</span>  获取浏览器发送的cookie</span></span><br></pre></td></tr></table></figure>

<p>###　(2).cookie的分类</p>
<p>会话级别的Cookie：<strong>默认的关闭了浏览器</strong>Cookie就销毁了. </p>
<p>持久级别的Cookie：可以设置指定cookie在浏览器的存活时间 , Cookie就不会随着浏览器关闭而 销毁了. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMaxAge</span><span class="params">(<span class="keyword">int</span> expiry)</span>  设置cookie的最大生存时间（单位：秒）,超过了该时间后Cookie会 自动销毁</span></span><br></pre></td></tr></table></figure>

<p>注意: cookie中没有删除cookie的方法，我们只能通过<strong>设置时间为0来删除</strong>这个cookie。</p>
<h3 id="3-cookie中编码问题"><a href="#3-cookie中编码问题" class="headerlink" title="(3).cookie中编码问题"></a>(3).cookie中编码问题</h3><p>​    cookie中的数据不能使用分号，逗号，空格。通常我们会使用url编码来解决这一问题，因为这个是java自带的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URLEncoder类：    </span><br><span class="line">	<span class="function"><span class="keyword">static</span> String <span class="title">encode</span><span class="params">(String s, String enc)</span>  将指定的字符串，按指定的编码表编 码</span></span><br><span class="line"><span class="function">URLDecoder类：    </span></span><br><span class="line"><span class="function">	<span class="keyword">static</span> String <span class="title">decode</span><span class="params">(String s, String enc)</span>  将指定的字符串，按指定的编码表解 码</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-session"><a href="#2-session" class="headerlink" title="2.session"></a>2.session</h2><h3 id="1-作用范围-2"><a href="#1-作用范围-2" class="headerlink" title="(1).作用范围"></a>(1).作用范围</h3><p>​    在一次会话使用该对象保存数据，一次会话（多次请求）内数据有效。</p>
<h3 id="2-生命周期-2"><a href="#2-生命周期-2" class="headerlink" title="(2).生命周期"></a>(2).生命周期</h3><p>​    创建:可以暂且认为在服务器第一次调用<strong>getSession()</strong>的时候.服务器创建session的对象.因为 session销毁后,再次调用getSession()的时候也会创建.</p>
<p> 销毁: </p>
<p>​    非正常关闭服务器 </p>
<p>​    Session过期了,在tomcat默认时间是30分钟. </p>
<p>​    手动调用session的invalidate的方法</p>
<h3 id="3-作用-2"><a href="#3-作用-2" class="headerlink" title="(3).作用"></a>(3).作用</h3><p>​    第一次使用getSession()是创建这个session，第二次是获取这个session。</p>
<p>​    实际上也不一定需要使用cookie才可以实现，还有<strong>url重写</strong>，就是在浏览器上写sessionId的信息。</p>
]]></content>
  </entry>
  <entry>
    <title>前端基础2</title>
    <url>/2020/05/29/javaweb/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<h1 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h1><p>​    JQuery是一个js的框架，封装了dom操作、事件、页面动画、异步操作等。</p>
<hr>
<h2 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1.基础语法"></a>1.基础语法</h2><p>​    用$()来选取元素，里面使用的是css选择器，其中jq与dom对象之间可以相互装换，</p>
<pre><code> dom对象 可以使用\$构造 例如\$(dom对象)   

jquery对象 可以使用数组取索引值的形式 例如 \$[index] 或 $.get(index) </code></pre><p>​    需要注意的是使用前要导这个库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"../js/jquery-1.11.3.js"</span>/&gt;</span><br><span class="line"><span class="comment">// 页面加载完 </span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"页面加载完成自动执行,匿名函数"</span>);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-基础操作"><a href="#2-基础操作" class="headerlink" title="2.基础操作"></a>2.基础操作</h2><p>​    在后面的使用xxx()来说明获取，使用xxx(内容)来说明修改。需要注意的是JQ与dom对象方法不互通。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. $.each() 用法示例 $.each(function(i,e)&#123;&#125;) 注意 e是dom对象</span></span><br><span class="line">  $lis.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log($(<span class="keyword">this</span>).text());<span class="comment">//遍历每一个jquery对象元素  </span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. text() 获取或修改文本内容 类似于 dom.innerText    </span></span><br><span class="line"><span class="comment">// 3. html() 获取或修改html内容 类似 dom.innerHTML</span></span><br><span class="line"><span class="comment">// 4. val() 获取或修改表单控件的value值 等于dom.value    </span></span><br><span class="line"><span class="comment">// 5. prop() 获取或修改原生属性值 等于 dom.properties    </span></span><br><span class="line"><span class="comment">// 6. attr() 获取或修改自定义属性值 等于 dom.setAttribute() dom.getAttribute()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 7. css() 获取或者修改CSS样式 用法            </span></span><br><span class="line"><span class="comment">	css(样式名) 获取一个样式 等于 dom.style.驼峰样式名            </span></span><br><span class="line"><span class="comment">	css(样式名,样式值) 设置一个样式 dom.style.驼峰样式名=样式值</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">"#p1"</span>).css(<span class="string">"color"</span>,<span class="string">"white"</span>);<span class="comment">//设置字体白色 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. toggleClass() 切换一个样式</span></span><br><span class="line">$p4.toggleClass(<span class="string">"mpp"</span>);<span class="comment">//切换 无则添加  </span></span><br><span class="line">$p4.toggleClass(<span class="string">"mpp"</span>);<span class="comment">//切换 有则删除</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-基础事件"><a href="#3-基础事件" class="headerlink" title="3.基础事件"></a>3.基础事件</h2><p>​    jquery事件与dom事件写法区别， jquery 都不要加on   <code>例如 $.click(函数)</code> ，dom对象都需要加on。</p>
<p>jquery常用事件   </p>
<ol>
<li>ready 页面加载完成    </li>
<li>blur 失去焦点    </li>
<li>change 表单控件的value值改变时    </li>
<li>mouseover mouseout hover 鼠标移入移出    </li>
<li>click 单击</li>
</ol>
<hr>
<h2 id="4-JSON"><a href="#4-JSON" class="headerlink" title="4.JSON"></a>4.JSON</h2><p>​    json是一种数据交换的形式。</p>
<p>JSON 语法规则    </p>
<ol>
<li>数据:{属性:值,属性:值}    </li>
<li>键值:键值之间是冒号,属性值与属性值之间是逗号    </li>
<li>对象:用{}表示    </li>
<li>数组:用[]表示</li>
</ol>
<p>JSON对象使用中常见的具体形式</p>
<pre><code>1. 对象类型        格式 {属性:值,属性:值}    </code></pre><ol start="2">
<li>数组/集合类型        格式 [值1,值2,值3]    </li>
<li>混合类型        <ol>
<li>对象中属性的值是数组            {属性:[值1,值2,值3],属性:[值1,值2,值3]}       </li>
<li>数组中的值是对象            [{属性:值,属性:值},{属性:值,属性:值}]</li>
</ol>
</li>
</ol>
<p>JSON对象与字符串转换的相关函数    </p>
<ol>
<li><p>JSON.stringify(object) 把对象转为字符串    </p>
</li>
<li><p>JSON.parse(string) 把字符串转为对象</p>
<p><strong>实际使用起来就是数组用索引和[]，对象用打点和{}。</strong></p>
</li>
</ol>
<hr>
<h2 id="5-Ajax"><a href="#5-Ajax" class="headerlink" title="5.Ajax"></a>5.Ajax</h2><p>​    ajax可以实现浏览器和服务器之间的异步通讯，至于异步就是有回调函数，发送后直接执行下面的语句，不会浪费系统资源。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123; </span><br><span class="line">    type:<span class="string">"get"</span>, <span class="comment">// 请求方式 get,post</span></span><br><span class="line">    url:<span class="string">"../data/student.txt"</span>, <span class="comment">// 服务器的地址</span></span><br><span class="line">    data:&#123;<span class="attr">name</span>:<span class="string">"张三"</span>,<span class="attr">pass</span>:<span class="number">123</span>&#125;, <span class="comment">// 请求的数据</span></span><br><span class="line">    dataType:<span class="string">"text"</span>, 	<span class="comment">// 返回的数据类型 text,json</span></span><br><span class="line">    <span class="keyword">async</span>:<span class="literal">true</span>, </span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;&#125;,  <span class="comment">// 成功</span></span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;&#125;  <span class="comment">// 失败</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写形式</span></span><br><span class="line"><span class="comment">// $.方式(地址,数据,成功函数,返回类型)</span></span><br><span class="line">$.<span class="keyword">get</span>("test.php", &#123; name: <span class="string">"张三"</span>, <span class="attr">pass</span>: <span class="string">"123"</span> &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);  </span><br><span class="line">&#125;);</span><br><span class="line">$.post(<span class="string">"test.php"</span>, &#123; <span class="attr">name</span>: <span class="string">"张三"</span>, <span class="attr">pass</span>: <span class="string">"123"</span> &#125;,  </span><br><span class="line">       <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;     </span><br><span class="line">    <span class="built_in">console</span>.log(response);   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​    </p>
]]></content>
  </entry>
  <entry>
    <title>前端基础</title>
    <url>/2020/05/18/javaweb/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一-HTML"><a href="#一-HTML" class="headerlink" title="一 HTML"></a>一 HTML</h1><p>​    HTML(Hyper Text Markup Language)超文本标记语言，不仅可以展示文字，还可以显示图片，超链接，音乐，视频等。</p>
<h2 id="1-书写规范"><a href="#1-书写规范" class="headerlink" title="1.书写规范"></a>1.书写规范</h2><p>​    HTML是一种标签语言，标签需要正确的嵌套，其实就是为了保证其树结构的完整，标签通常有两种写法。</p>
<ul>
<li><title>index</title>
  <meta name="generator" content="hexo-theme-yilia-plus">  有开始和结束标签</li>
<li><meta /> 自闭和标签

</li>
</ul>
<hr>
<h2 id="2-HTML常用便签"><a href="#2-HTML常用便签" class="headerlink" title="2.HTML常用便签"></a>2.HTML常用便签</h2><ol>
<li><p><strong>标题hn</strong> </p>
<h1>标题</h1>
</li>
<li><p><strong>水平线hr</strong></p>
<hr/>
</li>
<li><p><strong>段落</strong> </p>
<p>俺是段落</p>
</li>
<li><p><strong>超链接</strong> </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.runoob.com "</span>&gt;</span>菜鸟我的api<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>图片</strong> </p>
<p>​    通常来说，不指定高度，可以用百分比来指定width（宽度），../代表返回上一级，alt是返回失败的信息。</p>
<img width="200px" src="../img/tupian.jpg" alt=""/> 
</li>
<li><p><strong>列表</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>无序<span class="tag">&lt;/<span class="name">li</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>无序<span class="tag">&lt;/<span class="name">li</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- order有序不用强记 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序<span class="tag">&lt;/<span class="name">li</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>容器</strong></p>
<p><span>有多少显示多少</span></p>
<div>必然占一行</div>
</li>
<li><p><strong>实体字符</strong></p>
<p>半个英语字母英文空格&amp;nbsp</p>
<p>一个汉字中文空格&amp;emsp</p>
<p>小于号&amp;lt</p>
<p>大于号&amp;gt</p>
</li>
<li><p><strong>表格</strong></p>
<p>table&gt;tr[行数]&gt;td[列数]</p>
</li>
<li><p><strong>表单</strong></p>
<p>​    表单必须会,下面的表单基本概况了需要掌握的内容，我不一一介绍，其中get与post的区别是get会在浏览器上显示，并且内容比post小。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span>    </span><br><span class="line">    姓名<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">placeholder</span>=<span class="string">"请您输入姓名"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span>   </span><br><span class="line">    密码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"userPass"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span>    </span><br><span class="line">    生日<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">name</span>=<span class="string">"userBirth"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span>    </span><br><span class="line">    性别<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"male"</span> <span class="attr">id</span>=<span class="string">"male"</span>  <span class="attr">checked</span>/&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"male"</span>&gt;</span> 男<span class="symbol">&amp;emsp;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span>    </span><br><span class="line">    	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"female"</span> <span class="attr">id</span>=<span class="string">"female"</span>/&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"female"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span>    </span><br><span class="line">    爱好<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> <span class="attr">value</span>=<span class="string">"smoke"</span>/&gt;</span> 抽烟 <span class="symbol">&amp;emsp;</span>    </span><br><span class="line">    	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> <span class="attr">value</span>=<span class="string">"drink"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span>喝酒 <span class="symbol">&amp;emsp;</span>    </span><br><span class="line">    	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> <span class="attr">value</span>=<span class="string">"perm"</span> <span class="attr">checked</span>/&gt;</span> 烫头<span class="symbol">&amp;emsp;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span>    </span><br><span class="line">    头像<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"userPic"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span>    </span><br><span class="line">    学历<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"userEdu"</span>&gt;</span>        </span><br><span class="line">    		<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>幼稚园<span class="tag">&lt;/<span class="name">option</span>&gt;</span>        </span><br><span class="line">    		<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span>小学园<span class="tag">&lt;/<span class="name">option</span>&gt;</span>       </span><br><span class="line">    		<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"3"</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>初中园<span class="tag">&lt;/<span class="name">option</span>&gt;</span>    <span class="tag">&lt;/<span class="name">select</span>&gt;</span>    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	简介<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"userDesc"</span> <span class="attr">cols</span>=<span class="string">"50"</span> <span class="attr">rows</span>=<span class="string">"10"</span>&gt;</span>默认值<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"清空按钮"</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交按钮"</span>/&gt;</span>    <span class="tag">&lt;<span class="name">br</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"普通按钮"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-小总结"><a href="#3-小总结" class="headerlink" title="3.小总结"></a>3.小总结</h2><p>​    HTML可以完成一个有基本内容的界面，而接下来学的css和js分别是美化和是页面动态起来。</p>
<hr>
<h1 id="二-CSS"><a href="#二-CSS" class="headerlink" title="二 CSS"></a>二 CSS</h1><p>​    CSS(Cascading Style Sheet)层叠样式表</p>
<p>​    层叠样式: 对同一个标签应用不同的样式,所有样式会叠加在一起展示出效果.</p>
<p>​    优点:把html内容和css样式分离,降低了耦合度,提高了样式复用性,而且还可以提供更强大的美化效果。</p>
<h2 id="1-选择器"><a href="#1-选择器" class="headerlink" title="1.选择器"></a>1.选择器</h2><ul>
<li><p>CSS格式 {样式名:样式值;样式名:样式值;}</p>
</li>
<li><p>css的样式有三种<strong>引入方式</strong>：</p>
<ul>
<li><p><strong>行内</strong>    在行内的style属性中添加样式</p>
<div style="font-weight:bold;">加粗</div>    

<p>   <strong>内部</strong>(内嵌)    在页面中的style标签中写样式,推荐放置在head中的底部</p>
<p>作用域 本页面 </p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span>       </span><br><span class="line">    h2&#123;           </span><br><span class="line"><span class="css">        <span class="selector-tag">color</span><span class="selector-pseudo">:green</span>;<span class="comment">/*字体颜色 绿色*/</span> </span></span><br><span class="line"><span class="css">        <span class="selector-tag">font-style</span><span class="selector-pseudo">:italic</span>;<span class="comment">/*倾斜*/</span></span></span><br><span class="line">    &#125;    </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>外部</strong>    使用link标签引入外部样式 作用域 所有引入的页面</p>
  <link href="../css/外部样式.css" rel="stylesheet"/> 

</li>
</ul>
</li>
</ul>
<hr>
<p> CSS基本<strong>选择器</strong>:    </p>
<p>​    1.标签 根据标签匹配元素 格式 <strong>标签{}</strong>   </p>
<p>​    2.类 根据class的值匹配元素 class属性是给标签归类添加样式 格式 <strong>.class{}</strong>   </p>
<p>​    3.ID 根据id值匹配元素 id属性是标签的唯一标志 <strong>#id{}</strong></p>
<p>  扩展选择器 </p>
<p>​    关系    </p>
<p>​    <strong>E,F</strong> 并列    </p>
<p>​    <strong>E F</strong> 后代 </p>
<p>​    属性    <strong>E[attribute=value]</strong></p>
<hr>
<h2 id="2-盒子模型理论"><a href="#2-盒子模型理论" class="headerlink" title="2.盒子模型理论"></a>2.盒子模型理论</h2><p>​    在前端中,万物皆盒子。</p>
<p><img src="img/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%8001.png" alt=""></p>
<p>​    盒子模型的组成: </p>
<ul>
<li>margin (外)边距 边框之外的距离 默认透明 </li>
<li>border 边框 可以设置边框的   (边框算是盒子中的内容)</li>
<li>padding (内)填充 边框和内容之间的距离 默认透明 </li>
<li>content 内容 是标签中内容放置区域</li>
</ul>
<hr>
<h1 id="三-JS"><a href="#三-JS" class="headerlink" title="三 JS"></a>三 JS</h1><p>​    javascript由ECMA script js的基础语法，BOM浏览器对象，DOM文档对象。</p>
<h2 id="1-JS介绍"><a href="#1-JS介绍" class="headerlink" title="1.JS介绍"></a>1.JS介绍</h2><p>JS三种输出方式    </p>
<ol>
<li>输出到浏览器控制台    <code>console.log();</code></li>
<li>输出html内容到页面    <code>document.write()</code></li>
<li>浏览器弹框输出字符    <code>alter()</code></li>
</ol>
<p>JS数据类型    常用数据类型        </p>
<ol>
<li>string 字符串类型       </li>
<li>number 数字 包括整数和小数类型       </li>
<li>boolean 布尔类型 值只有 true和false 两个     </li>
<li>object 对象类型 空对象使用 null表示  5. undefined 变量未赋值</li>
</ol>
<p>JS与java不同: </p>
<ol>
<li>“+”只要两个都为数字可以不论类型来相加,</li>
<li>“==” 可以不论类型判断数字相等,  “= = =”才是判断类型与数据相等</li>
<li>判断是否不一定要布尔类型,只要默认就是否</li>
</ol>
<hr>
<h2 id="2-事件"><a href="#2-事件" class="headerlink" title="2.事件"></a>2.事件</h2><p>​    js代码不一定在运行后执行，它有些代码可以通过绑定事件，直到事件发生才执行绑定事件中的代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">事件的绑定方式</span></span><br><span class="line"><span class="comment">   事件种类</span></span><br><span class="line"><span class="comment">   1. 命名函数 没有this绑定,需要手动传递this</span></span><br><span class="line"><span class="comment">   2. 匿名函数 默认有this绑定,可以直接使用</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span> <span class="attr">onclick</span>=<span class="string">"myf1(this)"</span> <span class="attr">title</span>=<span class="string">"我是p1"</span>&gt;</span>1. 命名函数<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p2"</span> <span class="attr">title</span>=<span class="string">"我是p2"</span>&gt;</span>2. 匿名函数<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">window</span>); <span class="comment">// window 浏览器对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//1. 命名函数 格式 onEvent="函数()"</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">myf1</span><span class="params">(obj)</span> </span>&#123; <span class="comment">// 命名函数绑定把方法调用给事件属性</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"命名函数执行"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window 浏览器对象</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//2. 匿名函数 格式 onEvent=函数</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> p2 = <span class="built_in">document</span>.querySelector(<span class="string">"#p2"</span>);</span></span><br><span class="line"><span class="actionscript">    p2.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;<span class="comment">// 当p2被点击时调用方法执行</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"匿名函数执行"</span>);</span></span><br><span class="line"><span class="handlebars"><span class="xml">        console.log(this);// <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p2"</span> <span class="attr">title</span>=<span class="string">"我是p2"</span>&gt;</span>2. 匿名函数<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    事件是js代码中的重点内容，必须掌握，其中后面的常用事件有页面加载（onload），键盘事件（key）,鼠标事件（mouse），元素改变（onchange），点击（onclick）等，需要注意的是js代码有<strong>on</strong>，这和jq不同。</p>
<hr>
<h2 id="3-BOM对象"><a href="#3-BOM对象" class="headerlink" title="3.BOM对象"></a>3.BOM对象</h2><p>​    js中会把整个浏览器当成一个对象,，从而对这个浏览器进行各种各样的操作。</p>
<p><strong>JS三个弹框</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> alert(<span class="string">"展示内容"</span>);   <span class="comment">// alert展示内容</span></span><br><span class="line"><span class="number">2.</span> <span class="keyword">let</span> boo = confirm(<span class="string">"你确定吗?"</span>);	<span class="comment">// comfirm可以返回布尔值</span></span><br><span class="line"><span class="number">3.</span> <span class="keyword">let</span> str = prompt(<span class="string">"请输入数据"</span>,<span class="number">123</span>);    <span class="comment">// prompt输入</span></span><br></pre></td></tr></table></figure>

<p><strong>JS两个定时器</strong></p>
<ol>
<li>setTimeout(函数,毫秒值)执行一次  setInterval(函数,毫秒值)执行无数次       </li>
<li>setTimeout销毁使用clearTimeout(定时器)    setInterval销毁使用clearInterval(定时器)</li>
</ol>
<p><strong>location地址</strong>    </p>
<ol>
<li>获取当前浏览器地址        location.href</li>
<li>刷新当前页面        location.reload();</li>
<li>跳转页面        location.href = “地址” ;</li>
</ol>
<hr>
<h2 id="4-DOM对象"><a href="#4-DOM对象" class="headerlink" title="4.DOM对象"></a>4.DOM对象</h2><p>​    DOM对象可以获取整个页面的文档数据，DOM对象其实就是一个文档数。</p>
<p><strong>获取元素</strong></p>
<ol>
<li>document.querySelector(CSS选择器) 根据css选择器获取一个元素对象        </li>
<li>document.querySelectorAll(CSS选择器) 根据css选择器获取元素对象数组集合 </li>
</ol>
<p><strong>操作内容</strong></p>
<ol>
<li>element.innerText; 获取或者修改元素的纯文本内容    </li>
<li>element.innerHTML; 获取或者修改元素的html内容   </li>
<li>element.outerHTML; 获取或者修改包含自身的html内容</li>
</ol>
<p><strong>操作属性</strong>    </p>
<ol>
<li><p>获取文本框的值,单选框或复选框的选中状态        </p>
<p>​    语法: element.properties 获取或者修改元素对象的<strong>原生属性</strong></p>
</li>
<li><p>给元素设置自定义属性        </p>
<p>​    语法: element.<strong>set</strong>Attribute(属性名,属性值) 给元素设置一个属性值,可以设置原生和自定义    </p>
</li>
<li><p>获取元素的自定义属性值        </p>
<p>​    语法: element.<strong>get</strong>Attribute(属性名) 获取元素的一个属性值,可以获取原生和自定义   </p>
</li>
<li><p>移除元素的自定义属性        </p>
<p>​    语法: element.<strong>remove</strong>Attribute(属性名)</p>
</li>
</ol>
<p><strong>操作样式</strong>    </p>
<ol>
<li><p>设置一个css样式        </p>
<p>​    语法: element.style.驼峰格式样式属性名   获取或者修改一个css样式    </p>
</li>
<li><p>批量设置css样式        </p>
<p>​    语法: element.style.cssText 获取后者修改 标签的style属性的文本值    </p>
</li>
<li><p>通过class设置样式        </p>
<p>​    语法: element.className 获取或者修改标签的class属性的文本值</p>
<p>这里我们通常是使用第二和第三种。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>反射基础</title>
    <url>/2020/05/16/java/%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一-类加载器"><a href="#一-类加载器" class="headerlink" title="一.类加载器"></a>一.类加载器</h1><p>​    程序运行后,第一次使用某个类时,就会将此类的class文件加载到内存中,并将此类的信息存储到一个class对象里。</p>
<a id="more"></a>

<h2 id="1-类加载时机"><a href="#1-类加载时机" class="headerlink" title="1 类加载时机"></a>1 类加载时机</h2><ol>
<li><p>创建类的实例。</p>
</li>
<li><p>类的静态变量，或者为静态变量赋值。</p>
</li>
<li><p>类的静态方法。</p>
</li>
<li><p>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象。</p>
</li>
<li><p>初始化某个类的子类。</p>
</li>
<li><p>直接使用java.exe命令来运行某个主类。</p>
<p>以上六种情况的任何一种，都可以导致JVM将一个类加载到方法区。</p>
</li>
</ol>
<h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2 类加载器"></a>2 类加载器</h2><p><strong>类加载器：是负责将磁盘上的某个class文件读取到内存并生成Class的对象。</strong></p>
<ul>
<li>Java中有三种类加载器，它们分别用于加载不同种类的class：<ul>
<li>启动类加载器(Bootstrap ClassLoader)：用于加载系统类库<JAVA_HOME>\bin目录下的class，例如：rt.jar。</li>
<li>扩展类加载器(Extension ClassLoader)：用于加载扩展类库<JAVA_HOME>\lib\ext目录下的class。</li>
<li>应用程序类加载器(Application ClassLoader)：用于加载我们自定义类的加载器。</li>
</ul>
</li>
</ul>
<h2 id="3-双亲委托机制"><a href="#3-双亲委托机制" class="headerlink" title="3 双亲委托机制"></a>3 双亲委托机制</h2><ul>
<li>“双亲委派模型”中，除了顶层的启动类加载器外（顶层为null），其余的类加载器都应当有自己的”父级类加载器”。</li>
<li>这种关系不是通过”继承”实现的，通常是通过”组合”实现的。通过”组合”来表示父级类加载器。实际上是包含的关系，即”子类”中可以有父类的加载器。</li>
<li>“双亲委派模型”的工作过程：<ul>
<li>某个”类加载器”收到类加载的请求，它首先不会尝试自己去加载这个类，而是把请求交给父级类加载器。</li>
<li>因此，所有的类加载的请求最终都会传送到顶层的”启动类加载器”中。</li>
<li>如果”父级类加载器”无法加载这个类，然后子级类加载器再去加载。</li>
</ul>
</li>
<li>双亲委派机制的好处：每次加载是都先用父类加载，这样就避免了自己不小心的编写的Object被它认为是自己的父类,使得这个不能用。</li>
</ul>
<hr>
<h1 id="二-反射"><a href="#二-反射" class="headerlink" title="二.反射"></a>二.反射</h1><p>​    什么叫反射？</p>
<p>​    高中我们学到，当生物受到外部刺激时，对外部刺激进行回应，称为反射。在java中，反射指的是程序在运行时，还能够依据目前运行时的状态，获取并操作类，换句话说为动态编程。</p>
<h2 id="1-class对象"><a href="#1-class对象" class="headerlink" title="1 class对象"></a>1 class对象</h2><h3 id="1-1-class对象的获取"><a href="#1-1-class对象的获取" class="headerlink" title="1.1 class对象的获取"></a>1.1 class对象的获取</h3><ul>
<li><p>方式1: 通过类名.class获得</p>
</li>
<li><p>方式2：通过对象名.getClass()方法获得</p>
</li>
<li><p>方式3：通过Class类的静态方法获得： static Class forName(“类全名”)</p>
<p>  <strong>每一个类的Class对象都只有一个。</strong></p>
</li>
</ul>
<h3 id="1-2-class常用方法"><a href="#1-2-class常用方法" class="headerlink" title="1.2 class常用方法"></a>1.2 class常用方法</h3><ul>
<li>String getSimpleName(); 获得类名字符串：类名</li>
<li>String getName();  获得类全名：包名+类名</li>
<li>T newInstance() ;  创建Class对象关联类的对象</li>
</ul>
<h2 id="2-反射之构造方法"><a href="#2-反射之构造方法" class="headerlink" title="2 反射之构造方法"></a>2 反射之构造方法</h2><h3 id="2-1-Constructor类概述"><a href="#2-1-Constructor类概述" class="headerlink" title="2.1 Constructor类概述"></a>2.1 Constructor类概述</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反射之操作构造方法的目的</span><br><span class="line">    * 获得Constructor对象来创建类的对象。</span><br><span class="line">    </span><br><span class="line">Constructor类概述</span><br><span class="line">    * 类中的每一个构造方法都是一个Constructor类的对象</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Class类中与Constructor相关的方法"><a href="#2-2-Class类中与Constructor相关的方法" class="headerlink" title="2.2 Class类中与Constructor相关的方法"></a>2.2 Class类中与Constructor相关的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function">Constructor <span class="title">getConstructor</span><span class="params">(Class... parameterTypes)</span></span></span><br><span class="line"><span class="function">        * 根据参数类型获得对应的Constructor对象。</span></span><br><span class="line"><span class="function">        * 只能获得<span class="keyword">public</span>修饰的构造方法</span></span><br><span class="line"><span class="function"> 2. Constructor <span class="title">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span></span></span><br><span class="line"><span class="function">        * 根据参数类型获得对应的Constructor对象</span></span><br><span class="line"><span class="function">    	* 可以是<span class="keyword">public</span>、<span class="keyword">protected</span>、<span class="params">(默认)</span>、<span class="keyword">private</span>修饰符的构造方法。</span></span><br><span class="line"><span class="function"> 3. Constructor[] <span class="title">getConstructors</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        获得类中的所有构造方法对象，只能获得<span class="keyword">public</span>的</span></span><br><span class="line"><span class="function"> 4. Constructor[] <span class="title">getDeclaredConstructors</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        获得类中的所有构造方法对象</span></span><br><span class="line"><span class="function">    	可以是<span class="keyword">public</span>、<span class="keyword">protected</span>、<span class="params">(默认)</span>、<span class="keyword">private</span>修饰符的构造方法。</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-Constructor对象常用方法"><a href="#2-3-Constructor对象常用方法" class="headerlink" title="2.3 Constructor对象常用方法"></a>2.3 Constructor对象常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function">T <span class="title">newInstance</span><span class="params">(Object... initargs)</span>"</span></span><br><span class="line"><span class="function"> 	根据指定的参数创建对象</span></span><br><span class="line"><span class="function">2. <span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">true</span>)</span></span></span><br><span class="line"><span class="function">   设置"暴力反射"——是否取消权限检查，<span class="keyword">true</span>取消权限检查，<span class="keyword">false</span>表示不取消</span></span><br></pre></td></tr></table></figure>

<h2 id="3-反射之操作成员方法"><a href="#3-反射之操作成员方法" class="headerlink" title="3 反射之操作成员方法"></a>3 反射之操作成员方法</h2><h3 id="3-1-Method类概述"><a href="#3-1-Method类概述" class="headerlink" title="3.1 Method类概述"></a>3.1 Method类概述</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反射之操作成员方法的目的</span><br><span class="line">    * 操作Method对象来调用成员方法</span><br><span class="line">    </span><br><span class="line">Method类概述</span><br><span class="line">    * 每一个成员方法都是一个Method类的对象。</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Class类中与Method相关的方法"><a href="#3-2-Class类中与Method相关的方法" class="headerlink" title="3.2 Class类中与Method相关的方法"></a>3.2 Class类中与Method相关的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="function">Method <span class="title">getMethod</span><span class="params">(String name,Class...args)</span></span>;</span><br><span class="line">    * 根据方法名和参数类型获得对应的构造方法对象，只能获得<span class="keyword">public</span>的</span><br><span class="line">* <span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name,Class...args)</span></span>;</span><br><span class="line">    * 根据方法名和参数类型获得对应的构造方法对象，包括<span class="keyword">public</span>、<span class="keyword">protected</span>、(默认)、<span class="keyword">private</span>的</span><br><span class="line">* Method[] getMethods();</span><br><span class="line">    * 获得类中的所有成员方法对象，返回数组，只能获得<span class="keyword">public</span>修饰的且包含父类的</span><br><span class="line">* Method[] getDeclaredMethods();</span><br><span class="line">    * 获得类中的所有成员方法对象，返回数组,只获得本类的，包括<span class="keyword">public</span>、<span class="keyword">protected</span>、(默认)、<span class="keyword">private</span>的</span><br></pre></td></tr></table></figure>

<h3 id="3-3-Method对象常用方法"><a href="#3-3-Method对象常用方法" class="headerlink" title="3.3 Method对象常用方法"></a>3.3 Method对象常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*  <span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">    * 调用指定对象obj的该方法</span></span><br><span class="line"><span class="function">    * args：调用方法时传递的参数</span></span><br><span class="line"><span class="function">*  <span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">true</span>)</span></span></span><br><span class="line"><span class="function">    设置"暴力访问"——是否取消权限检查，<span class="keyword">true</span>取消权限检查，<span class="keyword">false</span>表示不取消</span></span><br></pre></td></tr></table></figure>

<h2 id="4-反射之操作成员变量"><a href="#4-反射之操作成员变量" class="headerlink" title="4 反射之操作成员变量"></a>4 反射之操作成员变量</h2><h3 id="4-1-Field类概述"><a href="#4-1-Field类概述" class="headerlink" title="4.1 Field类概述"></a>4.1 Field类概述</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反射之操作成员变量的目的</span><br><span class="line">    * 通过Field对象给对应的成员变量赋值和取值</span><br><span class="line"></span><br><span class="line">Field类概述</span><br><span class="line">    * 每一个成员变量都是一个Field类的对象。</span><br></pre></td></tr></table></figure>

<h3 id="4-2-Class类中与Field相关的方法"><a href="#4-2-Class类中与Field相关的方法" class="headerlink" title="4.2 Class类中与Field相关的方法"></a>4.2 Class类中与Field相关的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="function">Field <span class="title">getField</span><span class="params">(String name)</span></span>;</span><br><span class="line">    *  根据成员变量名获得对应Field对象，只能获得<span class="keyword">public</span>修饰</span><br><span class="line">* <span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span></span>;</span><br><span class="line">    *  根据成员变量名获得对应Field对象，包括<span class="keyword">public</span>、<span class="keyword">protected</span>、(默认)、<span class="keyword">private</span>的</span><br><span class="line">* Field[] getFields();</span><br><span class="line">    * 获得所有的成员变量对应的Field对象，只能获得<span class="keyword">public</span>的</span><br><span class="line">* Field[] getDeclaredFields();</span><br><span class="line">    * 获得所有的成员变量对应的Field对象，包括<span class="keyword">public</span>、<span class="keyword">protected</span>、(默认)、<span class="keyword">private</span>的</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Field对象常用方法"><a href="#4-3-Field对象常用方法" class="headerlink" title="4.3 Field对象常用方法"></a>4.3 Field对象常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">set</span><span class="params">(Object obj, Object value)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(Object obj, <span class="keyword">int</span> i)</span> 	</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLong</span><span class="params">(Object obj, <span class="keyword">long</span> l)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBoolean</span><span class="params">(Object obj, <span class="keyword">boolean</span> z)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDouble</span><span class="params">(Object obj, <span class="keyword">double</span> d)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object obj)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span>	<span class="title">getInt</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLong</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(Object ob)</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">true</span>)</span></span>;暴力反射，设置为可以直接访问私有类型的属性。</span><br><span class="line"><span class="function">Class <span class="title">getType</span><span class="params">()</span></span>; 获取属性的类型，返回Class对象。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>setXxx方法都是给对象obj的属性设置使用，针对不同的类型选取不同的方法。</p>
<p>getXxx方法是获取对象obj对应的属性值的，针对不同的类型选取不同的方法。</p>
</blockquote>
<hr>
<h1 id="三-动态代理"><a href="#三-动态代理" class="headerlink" title="三.动态代理"></a>三.动态代理</h1>]]></content>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2020/05/15/java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一-网络编程"><a href="#一-网络编程" class="headerlink" title="一.网络编程"></a>一.网络编程</h1><h2 id="1-1-软件结构"><a href="#1-1-软件结构" class="headerlink" title="1.1 软件结构"></a>1.1 软件结构</h2><ul>
<li>C/S结构 : 全称为Client/Server结构,指客户端和服务器结构</li>
<li>B/S结构 : 全称为Browser/Server结构，是指浏览器和服务器结构。</li>
</ul>
<hr>
<a id="more"></a>



<h2 id="1-2-网络编程的三要素"><a href="#1-2-网络编程的三要素" class="headerlink" title="1.2 网络编程的三要素"></a>1.2 网络编程的三要素</h2><p>​    网络编程的三要素分别是协议，IP地址，端口号。通过这三个组合，我们就可以进行网络传输。</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>​    协议 : 通信协议是计算机必须遵守的规则，只有遵守这些规则，计算机之间才能进行通信。</p>
<p>​    TCP/IP协议 : TCP/IP应该是整个网络协议中最伟大的发明,它规定了数据的运输的标准。</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>​    IP地址：    指<strong>互联网协议地址</strong>，俗称ip。用来表示一个网络中的计算机设备的唯一标志号。</p>
<ul>
<li><p><strong>IPv4</strong></p>
<p>​    IPv4是一个32位的二进制数，通常被分为4个字节。有资料显示，全球IPv4地址在2011年2月分配完毕，除去前期分配资源随意外，其实本质上IPv4的大小设计之初，本身就没有考虑到互联网会蓬勃发展到现在的程度。</p>
</li>
<li><p><strong>NAT</strong></p>
<p>通过NAT(网络地址转换 )，实现多个私网使用同一个公网的ip地址。简单来讲，就是节省大量的IP地址。</p>
</li>
<li><p><strong>IPv6</strong></p>
<p>为了从根本上解决IPv4的地址不够的问题,拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数。</p>
</li>
</ul>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>​    要知道，我们的通信可不是将内容传递的计算机就完事了。传到计算机给谁看？<strong>进程</strong>，我们使用的应用程序。</p>
<p>​    端口号：用两个字节表示的整数，它的取值范围是0<del>65535。其中，0</del>1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</p>
<hr>
<h1 id="二-BIO"><a href="#二-BIO" class="headerlink" title="二.BIO"></a>二.BIO</h1><p>​    BIO,在这里可以理解为阻塞的IO,即每一个请求都必须等待到回应。每次处理另开一个线程，如果阻塞了就等待其他线程处理完毕。BIO面向流,只能单向运输,处理资源慢。</p>
<hr>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><ul>
<li><p>TCP相关的类</p>
<p>Socket</p>
<pre><code>一个该类的对象就代表一个客户端程序。</code></pre><p>ServerSocket</p>
<pre><code>一个该类的对象就代表一个服务器端程序。</code></pre></li>
<li><p>Socket类构造方法</p>
<p>​     Socket(String host, int port)</p>
<pre><code>根据ip地址字符串和端口号创建客户端Socket对象
注意事项：只要执行该方法，就会立即连接指定的服务器程序，如果连接不成功，则会抛出异常。
   如果连接成功，则表示三次握手通过</code></pre></li>
<li><p>Socket类常用方法</p>
<p>​     OutputStream getOutputStream(); 获得字节输出流对象</p>
<pre><code>InputStream getInputStream();获得字节输入流对象</code></pre></li>
</ul>
<hr>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>​    我们通过一个文件上传的案例来揭开网络运输的神秘面纱。</p>
<hr>
<h3 id="模拟服务器端"><a href="#模拟服务器端" class="headerlink" title="模拟服务器端"></a>模拟服务器端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器启动中..."</span>);</span><br><span class="line">        <span class="comment">// 1.创建服务器端对象,本机IP,设置端口号为6666</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.创建循环，建立接受</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = serverSocket.accept(); <span class="comment">// 阻塞方法</span></span><br><span class="line">            <span class="comment">// 3.将socket对象交给子线程处理，进行读写操作</span></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                        <span class="comment">// 3.1 创建缓存输入流对象</span></span><br><span class="line">                        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(socket.getInputStream());</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 3.2 创建缓存输出流对像</span></span><br><span class="line">                        FileOutputStream fop = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fop);</span><br><span class="line">                ) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.3 读写数据,基本操作</span></span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">while</span>((len = bis.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                        bos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    socket.shutdownInput(); <span class="comment">// 读完的标志</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 4.信息回写</span></span><br><span class="line">                    System.out.println(<span class="string">"回写中..."</span>);</span><br><span class="line">                    OutputStream out = socket.getOutputStream();</span><br><span class="line">                    out.write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">                    out.close();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 5.关闭资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    fop.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传成功。"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模拟客户端"><a href="#模拟客户端" class="headerlink" title="模拟客户端"></a>模拟客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流对象，读取本地文件</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流对象，写到服务器端</span></span><br><span class="line">        Socket localhost = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(localhost.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.写出数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(b)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(b,<span class="number">0</span>,len);</span><br><span class="line">            bos.flush();<span class="comment">//这里必须实时刷新</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭输入流，通知服务器端，写出数据完毕</span></span><br><span class="line">        localhost.shutdownInput();</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.解析回写</span></span><br><span class="line">        InputStream in = localhost.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] back = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        in.read(back);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(back));</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="三-NIO"><a href="#三-NIO" class="headerlink" title="三.NIO"></a>三.NIO</h1><p>​    NIO就是在java中指同步非阻塞的IO，计算机会轮询该数据是否有该数据。其中这个线程不会阻塞其他线程，虽然由于同步停在了那一步，不过其他线程可以先执行。</p>
<p>​    NIO可以解决BIO中的几个点，首先BIO是面向流的，读写是分开的，我们每次都要创建读写两个流，浪费系统资源。其次BIO中是一个字节一个字节的，这样数据量大的情况下，读写操作会非常费时间。每一个请求都会产生一个线程，这样会产生大量的线程，即使使用线程池的技术，我们也会发现其实有大量资源浪费。</p>
<p>​    NIO中有三个重要的知识点，通道(channel)，缓存(Buffer)，选择器(select)。</p>
<hr>
<h2 id="3-1-Buffer"><a href="#3-1-Buffer" class="headerlink" title="3.1 Buffer"></a>3.1 Buffer</h2><p>​    缓存不仅仅只是一个数组，它实现了许多对数据结构化，使得数据简化读写操作。</p>
<ul>
<li><p>1 创建Buffer</p>
<ul>
<li><p>方式一：在堆中创建缓冲区：allocate(int capacity)</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建堆缓冲区</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：在系统内存创建缓冲区：allocatDirect(int capacity)</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建直接缓冲区</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三：通过数组创建缓冲区：wrap(byte[] arr)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">byte</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.wrap(byteArray);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在堆中创建缓冲区称为：<strong>间接缓冲区</strong></p>
</li>
<li><p>在系统内存创建缓冲区称为：<strong>直接缓冲区</strong></p>
</li>
<li><p>间接缓冲区的创建和销毁效率要高于直接缓冲区,间接缓冲区的工作效率要低于直接缓冲区</p>
</li>
</ul>
</li>
<li><p>2 添加数据</p>
<ul>
<li>public ByteBuffer put(byte b)：向当前可用位    置添加数据。</li>
<li>public ByteBuffer put(byte[] byteArray)：向当前可用位置添加一个byte[]数组</li>
<li>public ByteBuffer put(byte[] byteArray,int offset,int len)：添加一个byte[]数组的一部分</li>
</ul>
</li>
<li><p>3  容量-capacity </p>
<p> Buffer的容量(capacity)是指：Buffer所能够包含的元素的最大数量。定义了Buffer后，容量是不可变的。</p>
</li>
<li><p>4 限制-limit</p>
<ul>
<li>限制limit是指：第一个不应该读取或写入元素的index索引。缓冲区的限制(limit)不能为负，并且不能大于容量。</li>
<li>有两个相关方法：<ul>
<li>public int limit()：获取此缓冲区的限制。</li>
<li>public Buffer limit(int newLimit)：设置此缓冲区的限制。</li>
</ul>
</li>
</ul>
</li>
<li><p>5 位置-position</p>
<ul>
<li>位置position是指：当前可写入的索引。位置不能小于0，并且不能大于”限制”。</li>
<li>有两个相关方法：<ul>
<li>public int position()：获取当前可写入位置索引。</li>
<li>public Buffer position(int p)：更改当前可写入位置索引。</li>
</ul>
</li>
</ul>
</li>
<li><p>6 标记-mark</p>
<ul>
<li>标记mark是指：当调用缓冲区的reset()方法时，会将缓冲区的position位置重置为该索引。不能为0，不能大于position。</li>
<li>相关方法：<ul>
<li>public Buffer mark()：设置此缓冲区的标记为当前的position位置。</li>
</ul>
</li>
</ul>
</li>
<li><p>7 其它方法</p>
<ul>
<li>public Buffer clear()：还原缓冲区的状态。<ul>
<li>将position设置为：0</li>
<li>将限制limit设置为容量capacity；</li>
<li>丢弃标记mark。</li>
</ul>
</li>
<li>public Buffer flip()：缩小limit的范围。<ul>
<li>将limit设置为当前position位置；</li>
<li>将当前position位置设置为0；</li>
<li>丢弃标记。</li>
</ul>
</li>
<li>public Buffer rewind()：重绕此缓冲区。<ul>
<li>将position位置设置为：0</li>
<li>限制limit不变。</li>
<li>丢弃标记。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-2-Channel"><a href="#3-2-Channel" class="headerlink" title="3.2 Channel"></a>3.2 Channel</h2><p>​    Channel（通道）：Channel是一个对象，可以通过它读取和写入数据，我们可以把它当成一个更好的流（事实上也是如此）。</p>
<h3 id="1-FileChannel类的基本使用"><a href="#1-FileChannel类的基本使用" class="headerlink" title="1 FileChannel类的基本使用"></a>1 FileChannel类的基本使用</h3><ul>
<li>java.nio.channels.FileChannel (抽象类)：用于读、写文件的通道。</li>
<li>FileChannel是抽象类，我们可以通过FileInputStream和FileOutputStream的getChannel()方法方便的获取一个它的子类对象。</li>
</ul>
<h3 id="2-MappedByteBuffer实现高效读写"><a href="#2-MappedByteBuffer实现高效读写" class="headerlink" title="2 MappedByteBuffer实现高效读写"></a>2 MappedByteBuffer实现高效读写</h3><ul>
<li><p>直接使用FileChannel结合ByteBuffer实现的管道读写，但并不能提高文件的读写效率。</p>
</li>
<li><p>ByteBuffer有个子类：MappedByteBuffer，它可以创建一个“直接缓冲区”，并可以将文件直接<strong>映射至内存</strong>，可以提高大文件的读写效率。不过会使得jvm无法直接操作程序。</p>
<ul>
<li>ByteBuffer(抽象类)</li>
</ul>
<p>​        |–MappedByteBuffer(抽象类)</p>
</li>
<li><p>可以调用FileChannel的map()方法获取一个MappedByteBuffer，map()方法的原型：</p>
<p>  <strong>MappedByteBuffer map(MapMode mode, long position, long size);</strong> </p>
</li>
</ul>
<h3 id="3-ServerSocketChannel和SocketChannel创建连接"><a href="#3-ServerSocketChannel和SocketChannel创建连接" class="headerlink" title="3 ServerSocketChannel和SocketChannel创建连接"></a>3 ServerSocketChannel和SocketChannel创建连接</h3><ul>
<li><p><strong>服务器端：ServerSocketChannel</strong>类用于连接的服务器端，它相当于：ServerSocket。</p>
</li>
<li><p>1). 调用ServerSocketChannel的静态方法open()：打开一个通道，新频道的套接字最初未绑定; 必须通过其套接字的bind方法将其绑定到特定地址，才能接受连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open()</span><br></pre></td></tr></table></figure>
</li>
<li><p>2). 调用ServerSocketChannel的实例方法bind(SocketAddress add)：绑定本机监听端口，准备接受连接。</p>
</li>
</ul>
<p>​        注：java.net.SocketAddress(抽象类)：代表一个Socket地址。</p>
<p>​                我们可以使用它的子类：java.net.InetSocketAddress(类)</p>
<pre><code>构造方法：InetSocketAddress(int port)：指定本机监听端口。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>3). 调用ServerSocketChannel的实例方法accept()：等待连接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SocketChannel accept = serverChannel.accept();</span><br><span class="line">System.out.println(<span class="string">"后续代码..."</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>客户端：SocketChannel</strong>类用于连接的客户端，它相当于：Socket。</p>
</li>
<li><p>1). 先调用SocketChannel的open()方法打开通道：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open()</span><br></pre></td></tr></table></figure>
</li>
<li><p>2). 调用SocketChannel的实例方法connect(SocketAddress add)连接服务器：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8888</span>));</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-3-selector选择器"><a href="#3-3-selector选择器" class="headerlink" title="3.3 selector选择器"></a>3.3 selector选择器</h2><p>​    多路复用，服务器端同时监听多个“端口”的情况。每个端口都要监听多个客户端的连接。使用了多路复用，只需要一个线程就可以处理多个通道，降低内存占用率，减少CPU切换时间，在高并发、高频段业务环境下有非常重要的优势。</p>
<p>​    通过selector将多个通道注册到一个选择器上，这样就可以用一个线程监听所有的通道，大大减少线程的切换。</p>
<ul>
<li><p><strong>如何创建一个Selector</strong></p>
<p><code>Selector selector = Selector.open();</code></p>
</li>
<li><p><strong>注册Channel到Selector</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key =channel.register(selector,SelectionKey.OP_READ)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>register()方法的第二个参数</strong></p>
</li>
</ul>
<ol>
<li><p>连接就绪–常量：SelectionKey.OP_CONNECT</p>
</li>
<li><p>接收就绪–常量：SelectionKey.OP_ACCEPT      (ServerSocketChannel在注册时只能使用此项)</p>
</li>
<li><p>读就绪–常量：SelectionKey.OP_READ</p>
</li>
<li><p>写就绪–常量：SelectionKey.OP_WRITE</p>
<p><strong>注意：对于ServerSocketChannel在注册时，只能使用OP_ACCEPT，否则抛出异常。</strong></p>
</li>
</ol>
<h2 id="3-4-多路连接"><a href="#3-4-多路连接" class="headerlink" title="3.4 多路连接"></a>3.4 多路连接</h2><ul>
<li><strong>Selector的keys()方法</strong><ul>
<li>此方法返回一个Set<SelectionKey>集合，表示：已注册通道的集合。每个已注册通道封装为一个SelectionKey对象。</li>
</ul>
</li>
<li><strong>Selector的selectedKeys()方法</strong><ul>
<li>此方法返回一个Set<SelectionKey>集合，表示：当前已连接的通道的集合。每个已连接通道同一封装为一个SelectionKey对象。</li>
</ul>
</li>
<li><strong>Selector的select()方法</strong><ul>
<li>此方法会<strong>阻塞</strong>，直到有至少1个客户端连接。</li>
<li>此方法会返回一个int值，表示有几个客户端连接了服务器。</li>
</ul>
</li>
</ul>
<h2 id="3-5-多路信息接受"><a href="#3-5-多路信息接受" class="headerlink" title="3.5 多路信息接受"></a>3.5 多路信息接受</h2><h3 id="模拟服务器端-1"><a href="#模拟服务器端-1" class="headerlink" title="模拟服务器端"></a>模拟服务器端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在一个selectionKey完成时，需要将其移除，不然就会同时有两个端口7777,8888,同时连接。</span></span><br><span class="line"><span class="comment">    就会报错</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01_</span>服务器端 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建3个通道</span></span><br><span class="line">        ServerSocketChannel channelA = ServerSocketChannel.open();</span><br><span class="line">        channelA.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">7777</span>));<span class="comment">// 监听端口</span></span><br><span class="line">        channelA.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel channelB = ServerSocketChannel.open();</span><br><span class="line">        channelB.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8888</span>));<span class="comment">// 监听端口</span></span><br><span class="line">        channelB.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel channelC = ServerSocketChannel.open();</span><br><span class="line">        channelC.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">9999</span>));<span class="comment">// 监听端口</span></span><br><span class="line">        channelC.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通道注册</span></span><br><span class="line">        channelA.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        channelB.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        channelC.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        Set&lt;SelectionKey&gt; keys = selector.keys();</span><br><span class="line">        System.out.println(<span class="string">"服务器的注册通道："</span>+keys.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"【服务端】等待连接..."</span>);</span><br><span class="line">            <span class="keyword">int</span> keyCount = selector.select();<span class="comment">// 阻塞方法</span></span><br><span class="line">            System.out.println(<span class="string">"连接的数量："</span>+keyCount);</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                ServerSocketChannel channel = (ServerSocketChannel) it.next().channel();</span><br><span class="line">                System.out.println(<span class="string">"等待端口："</span> + channel.getLocalAddress() + <span class="string">""</span>);</span><br><span class="line">                SocketChannel socketChannel = channel.accept(); <span class="comment">// 非堵塞方法</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接受数据</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);<span class="comment">// 创建读的缓存区</span></span><br><span class="line">                socketChannel.read(buffer);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                System.out.println(<span class="string">"从"</span> + channel.getLocalAddress() + <span class="string">"获得消息："</span>);</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.limit()));</span><br><span class="line">                it.remove(); <span class="comment">// 移除selectionKey</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"————————————"</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模拟客户端-1"><a href="#模拟客户端-1" class="headerlink" title="模拟客户端"></a>模拟客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02_</span>客户端 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 创建一个通道</span></span><br><span class="line">            <span class="keyword">try</span>(SocketChannel channel = SocketChannel.open();)&#123;</span><br><span class="line">                System.out.println(<span class="string">"【客户端】正在连接..."</span>);</span><br><span class="line">                channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">7777</span>));</span><br><span class="line">                System.out.println(<span class="string">"【客户端】连接成功"</span>);</span><br><span class="line">                <span class="comment">// 发送信息</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>); <span class="comment">// 缓存</span></span><br><span class="line">                buffer.put(<span class="string">"伞兵一号卢本伟准备就绪"</span>.getBytes());</span><br><span class="line">                buffer.flip();</span><br><span class="line">                channel.write(buffer);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">"7777端口连接异常"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 创建一个通道</span></span><br><span class="line">            <span class="keyword">try</span>(SocketChannel channel = SocketChannel.open();)&#123;</span><br><span class="line">                System.out.println(<span class="string">"【客户端】正在连接..."</span>);</span><br><span class="line">                channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8888</span>));</span><br><span class="line">                System.out.println(<span class="string">"【客户端】连接成功"</span>);</span><br><span class="line">                <span class="comment">// 发送信息</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                buffer.put(<span class="string">"给阿姨倒一杯卡布奇诺"</span>.getBytes());</span><br><span class="line">                buffer.flip();</span><br><span class="line">                channel.write(buffer);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">"8888端口连接异常"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="四-AIO"><a href="#四-AIO" class="headerlink" title="四.AIO"></a>四.AIO</h1><p>​    前面的NIO实际上还是同步的，依旧是要等待结果，那么有没有更快的呢?</p>
<p>​    有，AIO。劳资直接不等了，爱啥时候回来啥时候回来（回调函数），我还有下面的代码要处理。</p>
<hr>
<h2 id="模拟服务器端-2"><a href="#模拟服务器端-2" class="headerlink" title="模拟服务器端"></a>模拟服务器端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_</span>服务器端 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建异步服务器通道对象</span></span><br><span class="line">        AsynchronousServerSocketChannel channel =</span><br><span class="line">                AsynchronousServerSocketChannel.open().</span><br><span class="line">                        bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步通道的连接</span></span><br><span class="line">        channel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel ch, Void attachment)</span> </span>&#123;</span><br><span class="line">                channel.accept(<span class="keyword">null</span>,<span class="keyword">this</span>);</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>); <span class="comment">// 缓存</span></span><br><span class="line">                System.out.println(<span class="string">"【服务器】开始read..."</span>);</span><br><span class="line">                ch.read(buffer, <span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;Integer, Void&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Void attachment)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(result == -<span class="number">1</span>)&#123;</span><br><span class="line">                            System.out.println(<span class="string">"客户端没有传输数据就close了..."</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">"【服务器】读取的数据："</span>+<span class="keyword">new</span> String(buffer.array(),<span class="number">0</span>,result));</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            ch.close();</span><br><span class="line">                            System.out.println(<span class="string">"服务器关闭"</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Void attachment)</span> </span>&#123;</span><br><span class="line">                        exc.printStackTrace();</span><br><span class="line">                        System.out.println(attachment);</span><br><span class="line">                        System.out.println(<span class="string">"服务器异常"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Void attachment)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"服务器开始循环"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模拟客户端-2"><a href="#模拟客户端-2" class="headerlink" title="模拟客户端"></a>模拟客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_</span>客户端 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        AsynchronousSocketChannel channel = AsynchronousSocketChannel.open();</span><br><span class="line">        channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8888</span>), <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">new</span> CompletionHandler&lt;Void, Void&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Void result, Void attachment)</span> </span>&#123;</span><br><span class="line">                        channel.write(ByteBuffer.wrap(</span><br><span class="line">                            <span class="string">"如果你今天能17张牌秒我，我当场把电脑屏幕吃掉"</span>.getBytes()), <span class="keyword">null</span>,</span><br><span class="line">                                <span class="keyword">new</span> CompletionHandler&lt;Integer, Void&gt;() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Void attachment)</span></span>&#123;</span><br><span class="line">                                        System.out.println(<span class="string">"输出完毕"</span>);</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Void attachment)</span> </span>&#123;</span><br><span class="line">                                        System.out.println(<span class="string">"输出失败"</span>);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            channel.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Void attachment)</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"【客服端】异常"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>IO操作</title>
    <url>/2020/04/23/java/IO%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="一-File类"><a href="#一-File类" class="headerlink" title="一.File类"></a>一.File类</h1><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<a id="more"></a>

<h2 id="1-1-构造方法"><a href="#1-1-构造方法" class="headerlink" title="1.1 构造方法"></a>1.1 构造方法</h2><p><code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。<br><code>public File(String parent, String child)</code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。<br><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </p>
<p>​    需要<strong>注意</strong>的是，File类创建并不会创建或者是覆盖文件。</p>
<hr>
<h2 id="1-2-常用方法"><a href="#1-2-常用方法" class="headerlink" title="1.2 常用方法"></a>1.2 常用方法</h2><p><code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串。<br><code>public String getPath()</code> ：将此File转换为路径名字符串。<br><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。<br><code>public long length()</code>  ：返回由此File表示的文件的长度。 不能获取目录的长度。</p>
<p><strong>绝对路径和相对路径</strong></p>
<p>  绝对路径：从盘符开始的路径，这是一个完整的路径。</p>
<p>  相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</p>
<p><strong>判断功能的方法</strong></p>
<p><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</p>
<p><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</p>
<p><code>public boolean isFile()</code> ：此File表示的是否为文件。</p>
<p><strong>创建删除功能的方法</strong></p>
<p><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </p>
<p><code>public boolean delete()</code> ：删除由此File表示的文件或目录。 </p>
<p><code>public boolean mkdir()</code> ：创建由此File表示的目录。</p>
<p><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</p>
<h2 id="1-3-目录的遍历"><a href="#1-3-目录的遍历" class="headerlink" title="1.3 目录的遍历"></a>1.3 目录的遍历</h2><p><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</p>
<p><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。  </p>
<hr>
<h1 id="二-字节流"><a href="#二-字节流" class="headerlink" title="二.字节流"></a>二.字节流</h1><p>​    一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都是一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<p>基本的传输过程：</p>
<p><img src="image/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.png" alt=""></p>
<hr>
<h2 id="2-1-字节输入流"><a href="#2-1-字节输入流" class="headerlink" title="2.1 字节输入流"></a>2.1 字节输入流</h2><p><code>java.io.OutputStream</code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<p><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </p>
<p><code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </p>
<p><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。</p>
<p><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </p>
<p><code>public abstract void write(int b)</code> ：将指定的字节输出流。</p>
<hr>
<h2 id="2-2-FileOutputStream类"><a href="#2-2-FileOutputStream类" class="headerlink" title="2.2 FileOutputStream类"></a>2.2 FileOutputStream类</h2><p>​    FileOutputStream 类是OutputStream的子类。是文件输出流，用于将数据写出到文件。</p>
<ul>
<li><p>构造方法</p>
<p><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </p>
<p><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。  </p>
</li>
<li><p>写出字节数据</p>
<p><code>write(int b)</code> 方法，每次可以写出一个字节数据</p>
<p><code>write(byte[] b)</code>，每次可以写出数组中的数据</p>
<p><code>write(byte[] b, int off, int len)</code> ,每次写出从off索引开始，len个字节</p>
</li>
<li><p>数据追加续写</p>
<p><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </p>
<p><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。</p>
<p>如果boolean类型值为true，表示追加数据</p>
<p>如果boolean类型值为false，表示清空原有数据</p>
</li>
<li><p>换行</p>
<p>在Windows里，换行符号是\r\n。</p>
</li>
</ul>
<hr>
<h2 id="2-3-字节输入流"><a href="#2-3-字节输入流" class="headerlink" title="2.3 字节输入流"></a>2.3 字节输入流</h2><p><code>java.io.InputStream</code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<p><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </p>
<p><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </p>
<p><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</p>
<hr>
<h2 id="2-4-FileInputStream类"><a href="#2-4-FileInputStream类" class="headerlink" title="2.4 FileInputStream类"></a>2.4 FileInputStream类</h2><ul>
<li><p>构造方法：</p>
<p><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的文件对象 file命名。 </p>
<p><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </p>
</li>
<li><p>读取字节数据</p>
<p><code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>。</p>
<p><code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1。</p>
</li>
</ul>
<hr>
<h2 id="2-5-复制文件"><a href="#2-5-复制文件" class="headerlink" title="2.5 复制文件"></a>2.5 复制文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个File对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:/code/data.txt"</span>);</span><br><span class="line">        <span class="comment">// 依据File对象来创建输入流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">// 一般可以直接用字符串，不用通过File对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"E"</span>);</span><br><span class="line">        <span class="comment">// 创建一个数组用来当做缓存区</span></span><br><span class="line">        <span class="comment">// 如果不使用len</span></span><br><span class="line">        <span class="comment">// 那么读最后一个数字时，数组中可能仍然有上一次读数据遗留下的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关流</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="三-字符流"><a href="#三-字符流" class="headerlink" title="三.字符流"></a>三.字符流</h1><p>​    我们在操作字节流的时候，会很明显地发现我们对于文字数据无法处理，假如以后有这么一个场景，我们将一些内容放在第一行，一些内容放在第二行…我们需要依据这些内容来对数据进行不同的处理。会发现很难处理，所以字符流出现了。</p>
<hr>
<h2 id="3-1-字符输入流"><a href="#3-1-字符输入流" class="headerlink" title="3.1 字符输入流"></a>3.1 字符输入流</h2><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<p><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </p>
<p><code>public int read()</code>： 从输入流读取一个字符。 </p>
<p><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</p>
<hr>
<h2 id="3-2-FileReader类"><a href="#3-2-FileReader类" class="headerlink" title="3.2 FileReader类"></a>3.2 FileReader类</h2><p><code>java.io.FileReader</code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<ul>
<li>构造方法</li>
</ul>
<p><code>public FileReader(File file)</code> : 创建字符输入流以写入由指定的 File对象表示的文件。</p>
<p><code>public FileReader(String fileName)</code> :  创建字符输入流以指定的名称写入文件。 </p>
<ul>
<li>读取字符数据</li>
</ul>
<p><code>read</code>方法 : 每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取。</p>
<p><code>read(char[] cbuf)</code>，每次读取多个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code>。</p>
<hr>
<h2 id="3-3-字符输出流【Writer】"><a href="#3-3-字符输出流【Writer】" class="headerlink" title="3.3 字符输出流【Writer】"></a>3.3 字符输出流【Writer】</h2><p><code>java.io.Writer</code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<p><code>public abstract void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </p>
<p><code>public abstract void flush()</code> ：刷新此输出流并强制任何缓冲的输出字符被写出。  </p>
<p><code>public void write(int c)</code> ：写出一个字符。</p>
<p><code>public void write(char[] cbuf)</code>：将 b.length字符从指定的字符数组写出此输出流。  </p>
<p><code>public abstract void write(char[] b, int off, int len)</code> ：从指定的字符数组写出 len字符，从偏移量 off开始输出到此输出流。  </p>
<p><code>public void write(String str)</code> ：写出一个字符串。</p>
<h2 id="1-4-FileWriter类"><a href="#1-4-FileWriter类" class="headerlink" title="1.4 FileWriter类"></a>1.4 FileWriter类</h2><p><code>java.io.FileWriter</code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<ul>
<li><p>构造方法</p>
<p><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </p>
<p><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </p>
</li>
<li><p>写出字符：</p>
<p><code>write(int b)</code> 方法，每次可以写出一个字符数据。</p>
<p><code>write(char[] cbuf)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream。</p>
<p><code>write(char[] cbuf, int off, int len)</code>，每次写出从off索引开始，len个字节</p>
</li>
<li><p>写出字符串:</p>
<p><code>write(String str)</code>    每次可以写出字符串中的数据</p>
<p><code>write(String str, int off, int len)</code> 每次可以写出字符串中从off索引开始，len个字的数据</p>
</li>
<li><p>续写和换行</p>
<p>与字节一模一样。</p>
</li>
</ul>
<blockquote>
<p>注意：</p>
<p>​    在字节流中内置缓冲区,如果在一次写完后没有刷新或关闭,会导致数据在缓存区而没有真正的写入内核中, 换句话说,数据不会写入磁盘,你下次来数据就没有了。</p>
<p>​    我们需要刷新或者关闭,前者主要在循环中多次读写,后者主要用在一次读写。            </p>
</blockquote>
<hr>
<h1 id="四-属性集与ResourceBundle类"><a href="#四-属性集与ResourceBundle类" class="headerlink" title="四.属性集与ResourceBundle类"></a>四.属性集与ResourceBundle类</h1><h2 id="4-1-属性集"><a href="#4-1-属性集" class="headerlink" title="4.1 属性集"></a>4.1 属性集</h2><p>​    前面我们提到放在磁盘中的数据是难以使用的,不过java中提供属性集了可以用于进行数据的操作,需要注意的是文本中的数据必须是键值对的形式，每个键及其对应值都是一个字符串。</p>
<hr>
<ul>
<li><p>构造方法</p>
<p><code>public Properties()</code> :创建一个空的属性列表。</p>
</li>
<li><p>存储方法</p>
<p><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </p>
<p><code>public String getProperty(String key)</code> ：使用此属性列表中指定的键搜索属性值。</p>
<p><code>public Set&lt;String&gt; stringPropertyNames()</code> ：所有键的名称的集合。</p>
</li>
<li><p>加载方法</p>
<p><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。 </p>
</li>
</ul>
<hr>
<h2 id="4-2-ResourceBundle类"><a href="#4-2-ResourceBundle类" class="headerlink" title="4.2 ResourceBundle类"></a>4.2 ResourceBundle类</h2><p>​    我们可以使用配置文件来简化我们的读取资源文件,虽然操作简洁,不过需求也变得多了。首先，properties配置文件需要放置在类的根路径src下面，文件的后缀名一定是Properties。</p>
<ul>
<li><p>对象的创建</p>
<p><code>static ResourceBundle getBundle(String baseName)</code> 该类为抽象类,提供了一个静态方法用来获取子类对象,<strong>注意不要后缀名</strong>,我们做这么多准备就是不想要后缀名。</p>
</li>
<li><p>读取方法</p>
<p><code>String getString(String key)</code>从此资源束或其父项之一获取给定字符串。</p>
</li>
</ul>
<hr>
<h1 id="五-缓冲流"><a href="#五-缓冲流" class="headerlink" title="五.缓冲流"></a>五.缓冲流</h1><p>​    之前的流都是基础,下面会有更为强大的流。缓冲流的原理就是在创建流的同时创建一个内部缓存区,降低IO的次数,进而缩短时间。</p>
<p>​    需要注意的是:缓冲流使用了<strong>装饰者设计模式</strong>,即继承同一父类,在装饰类中创建被装饰的类的实例,需要就改,不需要改就保存原样。</p>
<hr>
<h2 id="5-1-字节缓冲流"><a href="#5-1-字节缓冲流" class="headerlink" title="5.1 字节缓冲流"></a>5.1 字节缓冲流</h2><ul>
<li><p>构造方法</p>
<p><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </p>
<p><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</p>
</li>
</ul>
<hr>
<h2 id="5-2-字符缓冲流"><a href="#5-2-字符缓冲流" class="headerlink" title="5.2 字符缓冲流"></a>5.2 字符缓冲流</h2><ul>
<li><p>构造方法</p>
<p><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </p>
<p><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</p>
</li>
<li><p>特有方法</p>
<p>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </p>
<p>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。</p>
</li>
</ul>
<hr>
<h1 id="六-转换流"><a href="#六-转换流" class="headerlink" title="六.转换流"></a>六.转换流</h1><p>​    计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本f符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p>
<hr>
<h2 id="6-1-InputStreamReader类"><a href="#6-1-InputStreamReader类" class="headerlink" title="6.1 InputStreamReader类"></a>6.1 InputStreamReader类</h2><ul>
<li><p>构造方法</p>
<p><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </p>
<pre><code>`InputStreamReader(InputStream in, String charsetName)`: 创建一个指定字符集的字符流。</code></pre></li>
</ul>
<hr>
<h2 id="6-2-OutputStreamWriter类"><a href="#6-2-OutputStreamWriter类" class="headerlink" title="6.2 OutputStreamWriter类"></a>6.2 OutputStreamWriter类</h2><ul>
<li><p>构造方法</p>
<p><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </p>
<p><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</p>
</li>
</ul>
<hr>
<h1 id="七-序列化"><a href="#七-序列化" class="headerlink" title="七.序列化"></a>七.序列化</h1><p>​    java提供了将对象序列化的机制,就是将一个对象的<strong>全部信息</strong>装换成可以持久存储的<strong>字节序列</strong>。</p>
<hr>
<h2 id="7-1-ObjectOutputStream类"><a href="#7-1-ObjectOutputStream类" class="headerlink" title="7.1 ObjectOutputStream类"></a>7.1 ObjectOutputStream类</h2><p>​    ObjectOutputStream类可以将一个对象输出成文件，实现对象的持久存储。</p>
<ul>
<li><p>构造方法</p>
<ul>
<li><code>public ObjectOutputStream(OutputStream out)</code>:创建一个指定OutputStream（字节输出流）的ObjectOutputStream。</li>
</ul>
</li>
<li><p>序列化操作</p>
<ul>
<li>一个对象想要实现序列化必须<code>java.io.Serializable</code> 接口,其中<code>Serializable</code>是一个标记接口,点进去后发现什么方法都没有实现。可是呢,如果不继承这个接口,那么就不能序列化成功,会抛错误</li>
<li>该类的所有属性必须是可序列化的,如果有一个属性不需要序列化,该属性必须注明是瞬态的,使用<code>transient</code> 关键字修饰。</li>
</ul>
</li>
<li><p>写出对象方法</p>
<ul>
<li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出</li>
</ul>
</li>
</ul>
<p>注意：序列化之后的文件是本来就是乱码的。</p>
<hr>
<h2 id="7-2-ObjectInputStream类"><a href="#7-2-ObjectInputStream类" class="headerlink" title="7.2 ObjectInputStream类"></a>7.2 ObjectInputStream类</h2><p>​    ObjectOutputStream类可以将一个文件输出成对象的原始对象。</p>
<ul>
<li>构造方法<ul>
<li><code>public ObjectInputStream(InputStream in)</code>： 创建一个指定InputStream（字节输入流）的ObjectInputStream。</li>
</ul>
</li>
<li>反序列化操作<ul>
<li><code>public final Object readObject ()</code> : 读取一个对象</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ol>
<li>反序列化操作必须是可以找到该类，否则会抛一个<code>ClassNotFoundException</code>异常。</li>
<li>假如我们序列化时是使用该类，反序列时却修改了该类，会抛出一个<code>InvalidClassException</code>异常</li>
</ol>
<p>​        针对第二种情况，我们引入一个<code>Serializable</code>（序列版本号）的概念，假如版本号一致，那么那些修改过的值将会被赋默认值。</p>
<hr>
<h1 id="八-打印流"><a href="#八-打印流" class="headerlink" title="八.打印流"></a>八.打印流</h1><h2 id="8-1-PrintStream类"><a href="#8-1-PrintStream类" class="headerlink" title="8.1 PrintStream类"></a>8.1 PrintStream类</h2><p><code>public PrintStream(String fileName)</code>： 使用指定的文件名创建一个新的打印流。</p>
]]></content>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2020/04/21/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一-线程"><a href="#一-线程" class="headerlink" title="一.线程"></a>一.线程</h1><h2 id="1-1-Thread类"><a href="#1-1-Thread类" class="headerlink" title="1.1 Thread类"></a>1.1 Thread类</h2><p>​    线程开启我们需要用到了<code>java.lang.Thread</code>类，API中该类中定义了有关线程的一些方法，具体如下：</p>
<a id="more"></a>

<p><strong>构造方法：</strong></p>
<ul>
<li><code>public Thread()</code>:分配一个新的线程对象。</li>
<li><code>public Thread(String name)</code>:分配一个指定名字的新的线程对象。</li>
<li><code>public Thread(Runnable target)</code>:分配一个带有指定目标新的线程对象。</li>
<li><code>public Thread(Runnable target,String name)</code>:分配一个带有指定目标新的线程对象并指定名字。</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li><p><code>public String getName()</code>:获取当前线程名称。</p>
</li>
<li><p><code>public void start()</code>:导致此线程开始执行; Java虚拟机调用此线程的run方法。</p>
</li>
<li><p><code>public void run()</code>:此线程要执行的任务在此处定义代码。</p>
</li>
<li><p><code>public static void sleep(long millis)</code>:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</p>
</li>
<li><p><code>public static Thread currentThread()</code>:返回对当前正在执行的线程对象的引用。</p>
<p>其中直接使用run()是指在当前的线程调用其中的方法，而使用start()则另开一条线程来调用run方法。</p>
</li>
</ul>
<hr>
<h2 id="1-2-多线程的创建"><a href="#1-2-多线程的创建" class="headerlink" title="1.2 多线程的创建"></a>1.2 多线程的创建</h2><p>多线程的创建分两种：</p>
<ul>
<li>直接继承Thread类</li>
<li>实现Runnable</li>
</ul>
<p><strong>直接继承Thread类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义指定线程名称的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不指定线程的名称，线程有默认的名字Thread-0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写run方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">"正在执行"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建自定义线程对象</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">"新的线程"</span>);</span><br><span class="line">        <span class="comment">// 开启新线程</span></span><br><span class="line">        mt.start();</span><br><span class="line">        <span class="comment">// 主函数中执行for循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main线程!"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现Runnable</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建自定义类对象 线程任务对象</span></span><br><span class="line">        MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mr,<span class="string">"小强"</span>);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main主方法线程："</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    实现多线程其实都是调用Thread中的start()方法来调用run(),问题就是哪里的run(),如果是继承方法实现的话，直接创建这个子类，实现的就是子类中的run()方法，如果是继承方法的话，那么先创建这个类，然后使用new Thread(mr,”线程名”)，那么就会使用mr中run()方法,不难。</p>
<p><strong>区别</strong>：<br>    要知道类与接口的区别，那就是类只能单继承，而接口可以多实现。</p>
<hr>
<h1 id="二-线程安全"><a href="#二-线程安全" class="headerlink" title="二.线程安全"></a>二.线程安全</h1><p>​    多线程有三个安全性问题：可见性，有序性，原子性。下面我会简单说出产生原因。</p>
<h2 id="2-1-可见性"><a href="#2-1-可见性" class="headerlink" title="2.1 可见性"></a>2.1 可见性</h2><p>​    可见性是指线程之间不能“看见”另一个值的改变，导致线程间的数据出现问题。</p>
<p><img src="image/%E5%8F%AF%E8%A7%81%E6%80%A7.png" alt=""></p>
<p>​    首先我们先有几个概念，线程开始会从内存中拿值，然后就不会再去内存再去拿值了，通常经过一定时间后，线程中的值会写回到内存中。</p>
<p>​    可见性的问题就这么产生了，其他线程不会知道某个线程是否改变自己线程中的值。</p>
<p><img src="image/%E5%8F%AF%E8%A7%81%E6%80%A71.png" alt=""></p>
<p>​    volatile关键字会使得这个值发生改变时，就让内存中的值改变，然后所有使用到这个值的线程将这个值改变。</p>
<hr>
<h2 id="2-2-有序性"><a href="#2-2-有序性" class="headerlink" title="2.2 有序性"></a>2.2 有序性</h2><p>​    线程间的执行顺序可能与我们想要的不同。</p>
<p><img src="image/%E6%9C%89%E5%BA%8F%E6%80%A7.png" alt=""></p>
<p>​    如果使用volatile关键字，当值改变时，必须等待前面的值都已经进行。换句话说，使用volatile关键字的会使得指令优化在这之前失效，在这的数据必须读写完成。</p>
<hr>
<h2 id="2-3-原子性"><a href="#2-3-原子性" class="headerlink" title="2.3 原子性"></a>2.3 原子性</h2><p>​    线程间会因为某个操作不是原子操作而产生线程安全问题。</p>
<p><img src="image/%E5%8E%9F%E5%AD%90%E6%80%A7.png" alt=""></p>
<p>​    </p>
<p>​    这张图线程一和线程二的操作都是a++,很明显a++不是原子操作。</p>
<p>​    那么我们可以用volatile关键字解决原子性问题吗？</p>
<p>​    很明显<strong>不行</strong>，如果两个线程中同时读到a=0，那么线程一只有在第三步操作之后才能将a写回内存中，可是线程二的a++在第一步时就已经读到了a=0,不会再回去执行读内存中a=1，那么线程安全问题就出现了。</p>
<p>​    我们可以用 AtomicInteger解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用AtomicInteger可以保证线程的原子性</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger a = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 线程的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// a ++ ;</span></span><br><span class="line">            a.getAndIncrement();<span class="comment">// 相当于 a++</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    其底层依靠CAS，源码分析如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CAS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 包含需要去读取的field的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset o中整型field的偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta o中需要添加的新值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 获取当前的内存中field的值</span></span><br><span class="line">            v = getIntVolatile(o, offset);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取v的值，和再一次取field的值，注意o和offset可能改变。判断是否相等</span></span><br><span class="line">            <span class="comment">// 如果没有其他线程改变过field值，那么就将这个值加上delta，下面的式子判断为false，循环结束</span></span><br><span class="line">            <span class="comment">// 否则下面的式子判断为true，循环继续</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 获取obj对象中offset偏移地址对应的整型field的值。</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> o 包含需要去读取的field的对象</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> offset o中整型field的偏移量</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="comment">// getIntVolatile中的o可以认为是数组中的地址,即arr，offset可以认为是索引，即i</span></span><br><span class="line">    <span class="comment">// （其实不大准确,这里面是地址和指针的关系）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较o的offset处内存位置中的值和期望的值，如果相同则更新。</span></span><br><span class="line"><span class="comment">     * （此更新是不可中断的，其他线程不可以干扰这一过程）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 需要更新的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset obj中整型field的偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expected 希望field中存在的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 如果期望值expect与field的当前值相同，设置filed的值为这个新值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果field的值被更改返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareAndSetInt(o, offset, expected, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    就是每次执行+1的原子操作时，都去检测是否冲突，如果冲突，就不执行，让其他线程执行。</p>
<hr>
<h1 id="三-线程同步"><a href="#三-线程同步" class="headerlink" title="三.线程同步"></a>三.线程同步</h1><p>​    前面我们使用了AtomicInteger解决了a++的操作，可是如果我们想要多个操作间相互不要被中断，那么就需要线程同步。</p>
<p>​    我们使用synchronized关键字：使得多行代码间同步，不会被其他线程从中间插入。</p>
<hr>
<h2 id="3-1-同步代码块"><a href="#3-1-同步代码块" class="headerlink" title="3.1 同步代码块"></a>3.1 同步代码块</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">     需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步锁</strong>:</p>
<p>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</p>
<ol>
<li>锁对象 可以是任意类型。</li>
<li>多个线程对象  要使用同一把锁。</li>
</ol>
<hr>
<h2 id="3-2-同步方法"><a href="#3-2-同步方法" class="headerlink" title="3.2 同步方法"></a>3.2 同步方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">   	可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步锁</strong></p>
<p>​      对于非static方法,同步锁就是this。  </p>
<p>​      对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。</p>
<p>​    我们需要注意的是如果我们的程序中有同步方法和同步代码块，又想使得这两者之间相互同步，互不干扰，那么需要将同步代码块中的锁对象和同步方法一致。</p>
<hr>
<h2 id="3-3-Lock锁"><a href="#3-3-Lock锁" class="headerlink" title="3.3 Lock锁"></a>3.3 Lock锁</h2><p>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p>
<ul>
<li><code>public void lock()</code>:加同步锁。</li>
<li><code>public void unlock()</code>:释放同步锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 创建锁</span></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行出票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 模拟出票操作,等待50毫米</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 得到线程名字并打印</span></span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">"正在出票"</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="四-并发包"><a href="#四-并发包" class="headerlink" title="四.并发包"></a>四.并发包</h1><p>​    java中提供了许多的并发包来处理多线程中线程安全问题。</p>
<h2 id="4-1-集合中的线程安全"><a href="#4-1-集合中的线程安全" class="headerlink" title="4.1 集合中的线程安全"></a>4.1 集合中的线程安全</h2><ol>
<li><p><strong>CopyOnWriteArrayList</strong>可以解决ArrayList线程安全的问题</p>
</li>
<li><p><strong>CopyOnWriteArraySet</strong>可以解决HashSet线程安全的问题</p>
</li>
<li><p><strong>ConcurrentHashMap</strong>可以解决HashMap线程安全的问题</p>
<p>​    Hashtable是线程安全的，但效率低，因为其内部对整个哈希表使用悲观锁，ConcurrentHashMap对哈希表间使用的是乐观锁，链表为悲观锁。</p>
</li>
</ol>
<hr>
<h2 id="4-2-CountDownLatch"><a href="#4-2-CountDownLatch" class="headerlink" title="4.2 CountDownLatch"></a>4.2 CountDownLatch</h2><p>​    CountDownLatch我理解为”倒数启动”，允许一个和多个线程等待其他线程完成操作。</p>
<p>CountDownLatch<strong>构造方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span><span class="comment">// 初始化一个指定计数器的CountDownLatch对象</span></span></span><br></pre></td></tr></table></figure>

<p>CountDownLatch<strong>重要方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">// 让当前线程等待</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span>	<span class="comment">// 计数器进行减1</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-3-CyclicBarrier"><a href="#4-3-CyclicBarrier" class="headerlink" title="4.3 CyclicBarrier"></a>4.3 CyclicBarrier</h2><p>​    CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
<p>CyclicBarrier<strong>构造方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景</span></span></span><br></pre></td></tr></table></figure>

<p>CyclicBarrier<strong>重要方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span><span class="comment">// 每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-4-Semaphore"><a href="#4-4-Semaphore" class="headerlink" title="4.4 Semaphore"></a>4.4 Semaphore</h2><p>​    Semaphore字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目。</p>
<p>​    Semaphore的主要作用是控制线程的并发数量。</p>
<p>​    Semaphore可以设置同时允许几个线程执行。</p>
<p>Semaphore<strong>构造方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span>						permits 表示许可线程的数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span>			fair 表示公平性，如果这个设为 <span class="keyword">true</span> 的话，下次执行的线程会是等待最久的线程</span></span><br></pre></td></tr></table></figure>

<p>Semaphore<strong>重要方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException	表示获取许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span>								<span class="title">release</span><span class="params">()</span> 表示释放许可</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-5-Exchanger"><a href="#4-5-Exchanger" class="headerlink" title="4.5 Exchanger"></a>4.5 Exchanger</h2><p>​    Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。</p>
<p>​    这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p>
<p>Exchanger构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Exchanger</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>Exchanger重要方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="五-线程池"><a href="#五-线程池" class="headerlink" title="五.线程池"></a>五.线程池</h1><p>​    线程池其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</p>
<p>​    如果核心线程数满,最大线程数还没有满,就放在等待队列中;如果核心线程数满,最大线程数满,就拒接本次请求。</p>
<ol>
<li>线程池的使用：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>); <span class="comment">// 包含2个线程</span></span><br><span class="line">        <span class="comment">// 创建Runnable实例对象</span></span><br><span class="line">         MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 自己创建线程对象，并启动</span></span><br><span class="line"><span class="comment">        Thread t = new Thread(mr);</span></span><br><span class="line"><span class="comment">        t.start();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从线程池里拿出线程对象</span></span><br><span class="line">        service.submit(mr);</span><br><span class="line">        service.submit(mr);</span><br><span class="line">        service.submit(mr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>线程池的使用（Callable）：</p>
<p>我们知道Runnable的接口是没有返回值的，如果我们想要可以在线程中获取到值的话就使用Callable接口。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">// 线程数量为2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写Runnable接口</span></span><br><span class="line">        Callable&lt;Double&gt; c = <span class="keyword">new</span> Callable&lt;Double&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Double <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Math.random();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从线程池中获取对象，并调用Callable的call方法</span></span><br><span class="line">        Future&lt;Double&gt; f1 = service.submit(c);</span><br><span class="line">        <span class="comment">// Future 调用get() 获取运算结果</span></span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line"></span><br><span class="line">        Future&lt;Double&gt; f2 = service.submit(c);</span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line"></span><br><span class="line">        Future&lt;Double&gt; f3 = service.submit(c);</span><br><span class="line">        System.out.println(f3.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="六-线程状态"><a href="#六-线程状态" class="headerlink" title="六.线程状态"></a>六.线程状态</h1><h2 id="6-1-死锁"><a href="#6-1-死锁" class="headerlink" title="6.1 死锁"></a>6.1 死锁</h2><p>​    线程之间彼此相互等待。</p>
<p>​    死锁的条件：1.有多把锁     2.有多个线程         3.有同步代码块嵌套</p>
<hr>
<h2 id="6-2-线程状态"><a href="#6-2-线程状态" class="headerlink" title="6.2 线程状态"></a>6.2 线程状态</h2><table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生条件</th>
</tr>
</thead>
<tbody><tr>
<td>NEW(新建)</td>
<td>线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread只有线程对象，没有线程特征。</td>
</tr>
<tr>
<td>Runnable(可运行)</td>
<td>线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。调用了t.start()方法   ：就绪（经典教法）</td>
</tr>
<tr>
<td>Blocked(锁阻塞)</td>
<td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</td>
</tr>
<tr>
<td>Waiting(无限等待)</td>
<td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</td>
</tr>
<tr>
<td>Timed Waiting(计时等待)</td>
<td>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。</td>
</tr>
<tr>
<td>Teminated(被终止)</td>
<td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td>
</tr>
</tbody></table>
<p><strong>计时等待</strong></p>
<p><code>public static void  sleep(long time)</code>  让当前线程进入到睡眠状态，到毫秒后自动醒来继续执行</p>
<p><strong>等待唤醒</strong></p>
<p><code>public void wait()</code> : 让当前线程进入到等待状态 此方法必须锁对象调用.</p>
<p><code>public void notify()</code> : 唤醒当前锁对象上一个等待状态的线程  此方法必须锁对象调用.</p>
<p><code>public void notifyAll()</code>：唤醒当前锁对象上所有等待状态的线程  此方法必须锁对象调用</p>
<p>下面一个案例来让三个线程按一定的顺序执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 表示该线程一直在执行</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">// 抢夺锁资源</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    	这里为什么不是if？</span></span><br><span class="line"><span class="comment">                    	如果是if的话，那么等待到有锁释放时并抢夺到锁，</span></span><br><span class="line"><span class="comment">                    	由于已经判断过flog，会一直执行下去</span></span><br><span class="line"><span class="comment">                    	while会回来执行判断执行顺序，保证效率</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="comment">// 判断flag来决定执行顺序</span></span><br><span class="line">                    <span class="keyword">while</span>(flag != <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();<span class="comment">// 无限等待并释放锁资源</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 执行该线程操作</span></span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"a"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"b"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"c"</span>);</span><br><span class="line">                        System.out.println();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">2000</span>);<span class="comment">// 计时等待</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        flag = <span class="number">2</span>;</span><br><span class="line">                        lock.notifyAll(); <span class="comment">// 唤醒所有等待的线程</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(flag != <span class="number">2</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="number">2</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"C"</span>);</span><br><span class="line">                        System.out.println();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        flag = <span class="number">3</span>;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(flag != <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="number">3</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"3"</span>);</span><br><span class="line">                        System.out.println();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="七-java中的锁实现"><a href="#七-java中的锁实现" class="headerlink" title="七.java中的锁实现"></a>七.java中的锁实现</h1><p>​    队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架。 </p>
<h2 id="7-1-同步队列"><a href="#7-1-同步队列" class="headerlink" title="7.1 同步队列"></a>7.1 同步队列</h2><p>​    当有一个线程获取不到锁时，将在后面添加一个结点。</p>
<p><img src="image/AQS%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B.png" alt=""></p>
<p>​    当有一个线程释放锁时，将释放头结点。</p>
<p><img src="image/AQS%E9%87%8A%E6%94%BE%E9%94%81png.png" alt=""></p>
<hr>
<h2 id="7-2-独占锁"><a href="#7-2-独占锁" class="headerlink" title="7.2 独占锁"></a>7.2 独占锁</h2><p>​    如果这个线程抢到锁的话，我们设置state为正数。线程如果处于可以抢夺锁资源的state为0。在队列中的线程的state为-1。</p>
<p>​    如果这个正数为1的，那么就是独占的例如Reentranlock，如果是有限的，那么就是Semaphore的原理。</p>
<hr>
<h2 id="7-3-共享锁"><a href="#7-3-共享锁" class="headerlink" title="7.3 共享锁"></a>7.3 共享锁</h2><p>​    如果这个state的正数为无限，即在头结点获取到锁以后，我们把后面结点的state也设为正数，有传染性。这就是共享锁。像是CountDownLatch，CyclicBarrier…</p>
]]></content>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2020/04/18/java/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="一-Collection集合"><a href="#一-Collection集合" class="headerlink" title="一.Collection集合"></a>一.Collection集合</h1><p>​    集合是java提供的一种容器，主要用于存储多种数据。</p>
<a id="more"></a>

<hr>
<h2 id="1-1-Collection集合的概述"><a href="#1-1-Collection集合的概述" class="headerlink" title="1.1 Collection集合的概述"></a>1.1 Collection集合的概述</h2><p>​    单例集合的图：</p>
<p><img src="image/%E9%9B%86%E5%90%88.png" alt=""></p>
<hr>
<h2 id="1-2-Collection集合"><a href="#1-2-Collection集合" class="headerlink" title="1.2 Collection集合"></a>1.2 Collection集合</h2><p>​    Collection是单列集合的父接口，所以它的方法是list和set通用的，虽然实现可能有所不同，但是Collection有的方法是一定有的。</p>
<ul>
<li><p><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</p>
</li>
<li><p><code>public void clear()</code> :清空集合中所有的元素。</p>
</li>
<li><p><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</p>
</li>
<li><p><code>public boolean contains(Object obj)</code>: 判断当前集合中是否包含给定的对象。</p>
</li>
<li><p><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</p>
</li>
<li><p><code>public int size()</code>: 返回集合中元素的个数。</p>
</li>
<li><p><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中</p>
<p>这些常用方法没有难的，这里也就不具体演示了，后面分析里如果有用到就提一下。</p>
</li>
</ul>
<hr>
<h2 id="1-3-Iterator迭代器"><a href="#1-3-Iterator迭代器" class="headerlink" title="1.3 Iterator迭代器"></a>1.3 Iterator迭代器</h2><p>​    首先我们需要知道为啥要迭代器，我们知道数组中有索引，链表中可没有，它是从头结点一直向后传输来达到遍历的目的。如果每次都这么写的话太麻烦了，java就提供了迭代器来进行遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 多态的方法建立ArrayList对象的集合</span></span><br><span class="line">       Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">// 添加元素要在创建迭代器前</span></span><br><span class="line">       coll.add(<span class="string">"张三"</span>);</span><br><span class="line">       coll.add(<span class="string">"李四"</span>);</span><br><span class="line">       coll.add(<span class="string">"王五"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 迭代器也有泛型，我们需要将它同coll的泛型一致</span></span><br><span class="line">       Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(it.hasNext())&#123;<span class="comment">// 判断是否有下一个元素</span></span><br><span class="line">           String s = it.next(); <span class="comment">// 获取这个元素并将指针指向下一个数</span></span><br><span class="line">           <span class="keyword">if</span>(s.contains(<span class="string">"张三"</span>))&#123;</span><br><span class="line">               it.remove();<span class="comment">// 使用迭代器的删除方法,如果不这么做会出现并发修改异常</span></span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               System.out.println(s);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="comment">//李四 王五</span></span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">    	<span class="comment">//下面的是增强for循环，也要注意不能增删</span></span><br><span class="line">    	<span class="keyword">for</span> (String s : coll) &#123;</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125;<span class="comment">//李四 王五</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1-4-泛型"><a href="#1-4-泛型" class="headerlink" title="1.4 泛型"></a>1.4 泛型</h2><p>​    如果什么都存就会使得到时时候什么方法都不清楚能不能用。泛型的使用，使得我们在使用集合是能规定集合类型，得到了编译时期的语法检查。</p>
<ul>
<li><p><strong>泛型的类定义</strong>：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名&lt;代表泛型的变量&gt; </span>&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>  在创建对象的时候确定泛型</p>
</li>
<li><p><strong>泛型的方法方法</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>  调用方法时，确定泛型的类型</p>
</li>
<li><p><strong>泛型的通配符</strong></p>
<p>？代表可以接收任意类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型不存在继承关系 </span></span><br><span class="line">Collection&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//这种是错误的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>泛型的上限</strong>：</p>
<ul>
<li>格式： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li>意义： <code>只能接收该类型及其子类</code></li>
</ul>
</li>
<li><p><strong>泛型的下限</strong>：</p>
<ul>
<li>格式： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li>意义： <code>只能接收该类型及其父类型</code></li>
</ul>
</li>
</ul>
<hr>
<h1 id="二-List接口"><a href="#二-List接口" class="headerlink" title="二.List接口"></a>二.List接口</h1><p>​    在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过<strong>索引</strong>来访问集合中的指定元素。List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p>
<h2 id="2-1-常用方法"><a href="#2-1-常用方法" class="headerlink" title="2.1 常用方法"></a>2.1 常用方法</h2><ul>
<li><p><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</p>
</li>
<li><p><code>public E get(int index)</code>:返回集合中指定位置的元素。</p>
</li>
<li><p><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</p>
</li>
<li><p><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</p>
<p>​    这些list的常用方法，其实不难理解，需要注意的是list的方法只能在list及子类能用，set就不能用了，因为它们没有索引。</p>
</li>
</ul>
<hr>
<h2 id="2-2-ArrayList集合"><a href="#2-2-ArrayList集合" class="headerlink" title="2.2 ArrayList集合"></a>2.2 ArrayList集合</h2><p>​    arraylist的底层为数组，有查询快，增删慢的特点。    </p>
<p>Arraylist的扩容原理源码分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayList的容量初始设置为10个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数minCapacity代表着size+1</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">		<span class="comment">//记录原来的长度</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">// 下面的语句为判空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        	<span class="comment">// 下面的语句主要的是第一个参数和第三个参数相加。</span></span><br><span class="line">        	<span class="comment">// 第二个参数是避免第三个参数为0，这样就不会添加数组的长度</span></span><br><span class="line">            <span class="keyword">int</span> newCapacity = ArraysSupport.newLength(oldCapacity,</span><br><span class="line">            		<span class="comment">// 为1</span></span><br><span class="line">                    minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span></span><br><span class="line">                    <span class="comment">// oldCapacity左移一位，空位补0，作为平常的添加的长度</span></span><br><span class="line">                    oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">/* preferred growth */</span>);</span><br><span class="line">            <span class="comment">// 以新的长度创建一个数组并作为返回值</span></span><br><span class="line">            <span class="keyword">return</span> elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 如果为空，返回初始或设置的更小长度的数组</span></span><br><span class="line">            <span class="keyword">return</span> elementData = <span class="keyword">new</span> Object[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 其实只要oldCapacity大于等于2，第三个参数都至少为1，不过怕就怕我们不小心设置初始长度小于2了</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将后两个参数的较大值，加上第一个参数，作为返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newLength</span><span class="params">(<span class="keyword">int</span> oldLength, <span class="keyword">int</span> minGrowth, <span class="keyword">int</span> prefGrowth)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert oldLength &gt;= 0</span></span><br><span class="line">        <span class="comment">// assert minGrowth &gt; 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> newLength = Math.max(minGrowth, prefGrowth) + oldLength;</span><br><span class="line">        <span class="keyword">if</span> (newLength - MAX_ARRAY_LENGTH &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> newLength;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hugeLength(oldLength, minGrowth);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-3-LinkedList集合"><a href="#2-3-LinkedList集合" class="headerlink" title="2.3 LinkedList集合"></a>2.3 LinkedList集合</h2><p>​    LinkedList底层是一个双向链表，有一个头指针和尾指针，有查询慢，增删快的特点。</p>
<ul>
<li>常用方法</li>
<li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li>
<li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li>
<li><code>public E getFirst()</code>:返回此列表的第一个元素。</li>
<li><code>public E getLast()</code>:返回此列表的最后一个元素。</li>
<li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li>
<li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li>
<li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li>
<li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li>
<li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li>
</ul>
<hr>
<h1 id="三-Collections类"><a href="#三-Collections类" class="headerlink" title="三.Collections类"></a>三.Collections类</h1><ul>
<li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。<h2 id="3-1-常用方法"><a href="#3-1-常用方法" class="headerlink" title="3.1 常用方法"></a>3.1 常用方法</h2></li>
</ul>
<p>  常用方法如下：</p>
<ul>
<li><p><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code>:往集合中添加一些元素。</p>
</li>
<li><p><code>public static void shuffle(List&lt;?&gt; list)</code>:打乱集合顺序。</p>
</li>
<li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p>
</li>
<li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</p>
<hr>
</li>
</ul>
<h2 id="3-2-Comparator比较器"><a href="#3-2-Comparator比较器" class="headerlink" title="3.2 Comparator比较器"></a>3.2 Comparator比较器</h2><p>​    Compare方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">参数</span><br><span class="line">         o1表示要比较的值</span><br><span class="line">         o2表示的是已经比较过的值</span><br><span class="line">     返回值</span><br><span class="line">         如果返回值是正数,就会把元素移动到后面(代表o1&gt;o2)</span><br><span class="line">         如果返回值是负数,就会把元素移动到前面(代表o1&lt;o2)</span><br><span class="line">         如果返回值是<span class="number">0</span>,就表示两个元素相同,就不移动(代表o1=o2)</span><br><span class="line">         如果是在set里，就不会添加进集合（这是set去重的原因）</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="四-Set接口"><a href="#四-Set接口" class="headerlink" title="四.Set接口"></a>四.Set接口</h1><p>​    set接口的特点：元素不可重复，元素是无序的，没有索引。</p>
<h2 id="4-1-HashSet集合"><a href="#4-1-HashSet集合" class="headerlink" title="4.1 HashSet集合"></a>4.1 HashSet集合</h2><p>HashSet的添加源码分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onlyIfAbsent用来控制是否能够修改值，为ture不能修改</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="comment">// 节点数组</span></span><br><span class="line">    Node&lt;K,V&gt; p; <span class="comment">// 用来记录哈希表中的值</span></span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 先对哈希表判空，如果没有数据则初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果在根据哈希值发现哈希表里没有这个数，为null了，直接添加这个节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// null代表的是下一个节点</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; </span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">// 先判断hash值是否相等，在判断键值是否相等，判断不为null</span></span><br><span class="line">        <span class="comment">// 如果为true说明键值相等。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 判断是否已经成为树了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 说明是哈希表加链表的结构</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 遍历到尾结点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果为链表长度8就树化</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在链表中遍历到了这个键值值，直接什么也不干</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 指针向后走一步</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明键值存在，</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 修改键值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回被修改的值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果size超过一定的值就要重新分配哈希</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image/hashmap.png" alt=""></p>
<hr>
<h2 id="4-2-LinkedHashSet集合"><a href="#4-2-LinkedHashSet集合" class="headerlink" title="4.2 LinkedHashSet集合"></a>4.2 LinkedHashSet集合</h2><p>​    linkedHashSet集合的特点是：    存取有序，元素不重复，没有索引。</p>
<p>​    为什么会存取有序呢，因为底层采用哈希表加链表的结构，在原本的结点上除去存储信息，左右指针外，还存着前一个和后一个结点位置信息的指针。</p>
<hr>
<h2 id="4-3-TreeSet集合"><a href="#4-3-TreeSet集合" class="headerlink" title="4.3 TreeSet集合"></a>4.3 TreeSet集合</h2><p>​    TreeSet集合的特点是：元素不重复，没有索引，会对元素进行排序</p>
<p>​    为什么会对元素进行排序呢，TreeSet中的元素必须实现 Comparable接口并重写compareTo()方法，TreeSet判断元素是否重复 、以及确定元素的顺序 靠的都是这个方法。</p>
<hr>
<h1 id="五-Map集合"><a href="#五-Map集合" class="headerlink" title="五.Map集合"></a>五.Map集合</h1><p>​    Map中的集合，元素是成对存在的。每个元素由键与值两部分组成，通过键可以找对所对应的值。Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。其中set的集合和map很像，需要记得是的重写hashCode()和equals()方法。</p>
<p>​    分别有HashMap，LinkedHashMap，TreeMap这三种常用集合</p>
<h2 id="5-1-Map的常用方法"><a href="#5-1-Map的常用方法" class="headerlink" title="5.1  Map的常用方法"></a>5.1  Map的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p>
<ul>
<li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li>
<li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li>
<li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li>
<li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
<li><code>public boolean containKey(Object key)</code>:判断该集合中是否有此键。</li>
</ul>
<hr>
]]></content>
  </entry>
  <entry>
    <title>git的使用</title>
    <url>/2020/03/12/%E6%97%A5%E5%BF%97/git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Dos的命令"><a href="#Dos的命令" class="headerlink" title="Dos的命令"></a>Dos的命令</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pwd    <span class="comment">//目前位置</span></span><br><span class="line">cat [文件名] <span class="comment">// 查看文件内容</span></span><br><span class="line">mkdir [文件名] <span class="comment">// 创建一个文件</span></span><br><span class="line">rm [文件名] <span class="comment">// 删除</span></span><br><span class="line">tail -n [num] [文件名] <span class="comment">// 查看尾部num行的内容</span></span><br><span class="line">cd a/b/c  <span class="comment">//进入</span></span><br><span class="line">cd ../..     <span class="comment">//出来</span></span><br><span class="line">vim [文件名]    <span class="comment">//编辑</span></span><br><span class="line">ls -l    <span class="comment">// 该列文件</span></span><br></pre></td></tr></table></figure>

<h3 id="vim的使用"><a href="#vim的使用" class="headerlink" title="vim的使用"></a>vim的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">:wq <span class="comment">// 保存并退出</span></span><br></pre></td></tr></table></figure>





<h3 id="git的初始化"><a href="#git的初始化" class="headerlink" title="git的初始化"></a>git的初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git init <span class="comment">// 在当前目录下创建一个 .git 文件</span></span><br></pre></td></tr></table></figure>



<h3 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h3><ul>
<li>将当前工作区文件加入暂存区</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add ./文件名（要后缀） <span class="comment">// 表示把这个文件加入暂存区</span></span><br><span class="line">git add ./	<span class="comment">// 表示把所有的工作区修改过的文件加入暂存区</span></span><br></pre></td></tr></table></figure>

<ul>
<li>把文件加入仓库</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"这里填写修改的信息"</span> <span class="comment">// 把仓库门口的文件加入本地仓库</span></span><br><span class="line">git commit --all -m <span class="string">"绯红之王"</span>	<span class="comment">// 直接把工作区的文件加入本地仓库，一步到位</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当前文件的状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git status	<span class="comment">// 表示当前文件的状态，</span></span><br><span class="line"> 			<span class="comment">//红色表示没有加入暂存区，绿色表示没有加入本地仓库，没有颜色代表已经添加完成或没有修改</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看日志    </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git log <span class="comment">// 最完整的形式</span></span><br><span class="line">git log --pretty=online <span class="comment">// 以一行的形式显示</span></span><br><span class="line">git log --online <span class="comment">// 基本同上，哈希值缩短</span></span><br><span class="line">git reflog <span class="comment">//Head&#123;移动到当前版本需要几步&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>版本前进后退</p>
<ul>
<li>soft命令：</li>
</ul>
<p>只移动本地区，当前状态为绿色，暂存区与本地区不同版本。</p>
<ul>
<li>mix命令</li>
</ul>
<p>移动本地区和暂存区，当前状态为红色，工作区与暂存区不同版本。</p>
<ul>
<li>hard命令</li>
</ul>
<p>移动本地区，暂存区和工作区，全部一致，状态安全。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git reset --hard [哈希值（不用全部）] <span class="comment">// 跳到哈希值一样的版本</span></span><br><span class="line">git reset --hard HEAD^ <span class="comment">// 只能后退，一个一步</span></span><br><span class="line">git reset --hard HEAd~[num] <span class="comment">// 只能后退，后退num步</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除文件和找回</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git rm [文件名] <span class="comment">//	删除文件</span></span><br><span class="line">git reset --hard [指针位置] <span class="comment">// 将文件回退到指针位置的版本</span></span><br></pre></td></tr></table></figure>

<ul>
<li>比较文件差异</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git diff [文件名] <span class="comment">// 将工作区的文件和暂存区的进行比较</span></span><br><span class="line">git diff [本地文件中历史版本][文件名] <span class="comment">// 将工作区的文件与本地库历								   // 史记录比较</span></span><br><span class="line">git diff <span class="comment">// 不带文件名，可以比较多个文件</span></span><br></pre></td></tr></table></figure>



<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ul>
<li>创建分支</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git branch [分支名] <span class="comment">// 创建分支</span></span><br><span class="line">git branch -v <span class="comment">// 查看分支</span></span><br><span class="line">git checkout[分支名] <span class="comment">// 切换分支</span></span><br><span class="line">git merge [被合并的分支名] <span class="comment">// 合并分支</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>冲突</p>
<p>首先将所有特殊符号删除，然后用merge，接着使用add和commit</p>
</li>
</ul>
<h3 id="推送到远端仓库"><a href="#推送到远端仓库" class="headerlink" title="推送到远端仓库"></a>推送到远端仓库</h3><h4 id="使用ssh创建远端仓库"><a href="#使用ssh创建远端仓库" class="headerlink" title="使用ssh创建远端仓库"></a>使用ssh创建远端仓库</h4><ol>
<li><p>生成秘钥和公钥</p>
<p> 在git上输入这串代码</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>​    在用户文件夹下创建 .ssh 文件夹，其中id_rsa为秘钥，id_rsa.pub为公钥。</p>
<ol start="2">
<li><p>把公钥推送到github上</p>
<p>把id_rsa.pub为公钥的内容复制到github上settings - SSH and GPG keys - key上，名字随便取。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>java的学习</title>
    <url>/2020/02/28/java%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        学习java基础中，使用到的代码和问题我都会放在这里。</p>
<h2 id="一-java的输入输出与数据类型"><a href="#一-java的输入输出与数据类型" class="headerlink" title="一 .java的输入输出与数据类型"></a>一 .java的输入输出与数据类型</h2><h3 id="输出代码"><a href="#输出代码" class="headerlink" title="输出代码"></a>输出代码</h3><p>​        每个语言都需要的hellowrold的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWrold</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello,World!!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        就是这么简单，不用解释了吧。</p>
<h3 id="输入代码"><a href="#输入代码" class="headerlink" title="输入代码"></a>输入代码</h3><p>​        输入代码其实也很简单，其实就是抓包，建立对象，输入;代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抓包,下面使用的Scanner才有意义</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"请输入数据："</span>);</span><br><span class="line">        <span class="comment">// 将系统输入的值放入sc里，sc名称可变</span></span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">// int型，注意大小写；可以接着写y，则一定第二个输入的值</span></span><br><span class="line">		<span class="keyword">int</span> x = sc.nextInt();</span><br><span class="line">        <span class="comment">// int y = sc.nextInt();</span></span><br><span class="line">        <span class="comment">// System.out.println("你输入的数据是：" + y);</span></span><br><span class="line">		System.out.println(<span class="string">"你输入的数据是："</span> + x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        </p>
]]></content>
  </entry>
  <entry>
    <title>Tinyhttpd的学习</title>
    <url>/2020/01/17/Tinyhttpd%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="1-main函数"><a href="#1-main函数" class="headerlink" title="1.main函数"></a>1.main函数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_sock = <span class="number">-1</span>;   </span><br><span class="line">    u_short port = <span class="number">4000</span>;</span><br><span class="line">    <span class="keyword">int</span> client_sock = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_name</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span>  client_name_len = <span class="keyword">sizeof</span>(client_name);</span><br><span class="line">    <span class="keyword">pthread_t</span> newthread;  <span class="comment">//定义一个线程，名字为newthread</span></span><br><span class="line"></span><br><span class="line">    server_sock = startup(&amp;port);   <span class="comment">//取出HTTP请求中的post</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"httpd running on port %d\n"</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        client_sock = accept(server_sock,</span><br><span class="line">                (struct sockaddr *)&amp;client_name,</span><br><span class="line">                &amp;client_name_len);</span><br><span class="line">        <span class="keyword">if</span> (client_sock == <span class="number">-1</span>)</span><br><span class="line">            error_die(<span class="string">"accept"</span>);</span><br><span class="line">        <span class="comment">/* accept_request(&amp;client_sock); */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;newthread , <span class="literal">NULL</span>, </span><br><span class="line">             (<span class="keyword">void</span> *)accept_request, </span><br><span class="line">             (<span class="keyword">void</span> *)(<span class="keyword">intptr_t</span>)client_sock) != <span class="number">0</span>) </span><br><span class="line">            perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(server_sock);    <span class="comment">//关闭</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用到的知识"><a href="#用到的知识" class="headerlink" title="用到的知识"></a>用到的知识</h3><ul>
<li>pthread_create函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> pthread_create(&amp;thread[t], <span class="literal">NULL</span>, PrintHello, &amp;t); </span><br><span class="line"><span class="comment">//若线程创建成功，则返回0。若线程创建失败，则返回出错编号，并且*thread中的内容是未定义的。</span></span><br><span class="line"><span class="comment">//第一个参数为指向线程标识符的指针。</span></span><br><span class="line"><span class="comment">//第二个参数用来设置线程属性。						</span></span><br><span class="line"><span class="comment">//第三个参数是线程运行函数的起始地址。	</span></span><br><span class="line"><span class="comment">//最后一个参数是运行函数的参数。</span></span><br></pre></td></tr></table></figure>

<h1 id="2-start-up函数"><a href="#2-start-up函数" class="headerlink" title="2.start up函数"></a>2.start up函数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startup</span><span class="params">(u_short *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> httpd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">name</span>;</span></span><br><span class="line">	<span class="comment">//创造一个TCP套接字，默认协议；放在httpd里；</span></span><br><span class="line">    httpd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (httpd == <span class="number">-1</span>)</span><br><span class="line">        error_die(<span class="string">"socket"</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;name, <span class="number">0</span>, <span class="keyword">sizeof</span>(name));<span class="comment">//把name里的数归0 </span></span><br><span class="line">    name.sin_family = AF_INET;<span class="comment">//IPv4的地址名</span></span><br><span class="line">    name.sin_port = htons(*port);<span class="comment">//端口名</span></span><br><span class="line">    name.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">//地址族</span></span><br><span class="line">    <span class="comment">//允许地址复用，成功返回0;失败返回-1</span></span><br><span class="line">    <span class="keyword">if</span> ((setsockopt(httpd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on))) &lt; <span class="number">0</span>)       </span><br><span class="line">    &#123;  </span><br><span class="line">        error_die(<span class="string">"setsockopt failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bind(httpd, (struct sockaddr *)&amp;name, <span class="keyword">sizeof</span>(name)) &lt; <span class="number">0</span>)<span class="comment">//将套接字与端口相连，成功返回0;失败返回-1</span></span><br><span class="line">        error_die(<span class="string">"bind"</span>);</span><br><span class="line">    <span class="keyword">if</span> (*port == <span class="number">0</span>)  <span class="comment">/* 如果动态分配端口 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">socklen_t</span> namelen = <span class="keyword">sizeof</span>(name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//bind函数以后调用getsockname来获取本地地址和端口，成功为0;失败为-1</span></span><br><span class="line">        <span class="keyword">if</span> (getsockname(httpd, (struct sockaddr *)&amp;name, &amp;namelen) == <span class="number">-1</span>)</span><br><span class="line">            error_die(<span class="string">"getsockname"</span>);</span><br><span class="line">        *port = ntohs(name.sin_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(httpd, <span class="number">5</span>) &lt; <span class="number">0</span>)<span class="comment">//等待端口连接，成功为0;失败为-1</span></span><br><span class="line">        error_die(<span class="string">"listen"</span>);</span><br><span class="line">    <span class="keyword">return</span>(httpd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="用到的知识-1"><a href="#用到的知识-1" class="headerlink" title="用到的知识"></a>用到的知识</h3><ul>
<li>socket函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">SOCKET  WSAAPI   <span class="title">socket</span> <span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">		IN <span class="keyword">int</span>  af,    <span class="comment">//一种地址格式描述。现在支持的格式只有PF_INET，它是ARPA网际地址格式</span></span></span></span><br><span class="line"><span class="function"><span class="params">		IN  <span class="keyword">int</span>  type,    <span class="comment">//要建立的套接字的类型描述</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//SOCK_DGRAM -&gt;UDP  ； SOCK_STREAM -&gt; TCP  ；SOCK_RAW -&gt; 其他</span></span></span></span><br><span class="line"><span class="function"><span class="params">		IN  <span class="keyword">int</span>  protocol  <span class="comment">//套接字使用的特定协议，如果调用者不希望指定协议，则置为0，使用默认的连接模式</span></span></span></span><br><span class="line"><span class="function"><span class="params">             )</span></span>;</span><br></pre></td></tr></table></figure>

<p>作用：此函数建立一个套接字，它给指定的地址族、数据类型和协议分配一个套接字描述符以及相关的资源。 </p>
<ul>
<li>setsockpt</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*　sockfd：标识一个套接口的描述字。</span></span><br><span class="line"><span class="comment">　　 level：选项定义的层次；支持SOL_SOCKET、IPPROTO_TCP、IPPROTO_IP和IPPROTO_IPV6。</span></span><br><span class="line"><span class="comment">　　 optname：需设置的选项。</span></span><br><span class="line"><span class="comment">　　 optval：指针，指向存放选项值的缓冲区。</span></span><br><span class="line"><span class="comment">　　 optlen：optval缓冲区长度。</span></span><br><span class="line"><span class="comment"> 　　 返回值：  成功返回0，失败返回 -1.  */</span></span><br></pre></td></tr></table></figure>

<p>作用： socket关闭之后并不会立即收回，而是要经历一个TIME_WAIT的阶段。此时对这个端口进行重新绑定就会出错。要想立即绑定端口，需要先设置 SO_REUSEADDR.</p>
<h1 id="accept-request函数"><a href="#accept-request函数" class="headerlink" title="accept_request函数"></a>accept_request函数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept_request</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> client = (<span class="keyword">intptr_t</span>)arg;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];<span class="comment">//缓存区</span></span><br><span class="line">    <span class="keyword">size_t</span> numchars;</span><br><span class="line">    <span class="keyword">char</span> method[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">char</span> url[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">size_t</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">int</span> cgi = <span class="number">0</span>;      <span class="comment">/* becomes true if server decides this is a CGI</span></span><br><span class="line"><span class="comment">                       * program */</span></span><br><span class="line">    <span class="keyword">char</span> *query_string = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//把请求方法放在method数组</span></span><br><span class="line">    numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    i = <span class="number">0</span>; j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!ISspace(buf[i]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(method) - <span class="number">1</span>))<span class="comment">//缓存未满</span></span><br><span class="line">    &#123;</span><br><span class="line">        method[i] = buf[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    j=i;</span><br><span class="line">    method[i] = <span class="string">'\0'</span>;</span><br><span class="line">	<span class="comment">//如果接受方式即不是"GET"也不是"POST"</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>) &amp;&amp; strcasecmp(method, <span class="string">"POST"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        unimplemented(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//POST,直接cgi置1</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">"POST"</span>) == <span class="number">0</span>)</span><br><span class="line">        cgi = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ISspace(buf[j]) &amp;&amp; (j &lt; numchars))</span><br><span class="line">        j++;</span><br><span class="line">    <span class="comment">//这里i为工作参数，j走到非空</span></span><br><span class="line">    <span class="keyword">while</span> (!ISspace(buf[j]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(url) - <span class="number">1</span>) &amp;&amp; (j &lt; numchars))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//存下url</span></span><br><span class="line">        url[i] = buf[j];</span><br><span class="line">        i++; j++;</span><br><span class="line">    &#125;</span><br><span class="line">    url[i] = <span class="string">'\0'</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//GET，GET在"?"之后为参数</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        query_string = url;</span><br><span class="line">        <span class="keyword">while</span> ((*query_string != <span class="string">'?'</span>) &amp;&amp; (*query_string != <span class="string">'\0'</span>))</span><br><span class="line">            query_string++;</span><br><span class="line">        <span class="keyword">if</span> (*query_string == <span class="string">'?'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//检测到"?",将cgi=1;</span></span><br><span class="line">            cgi = <span class="number">1</span>;</span><br><span class="line">            *query_string = <span class="string">'\0'</span>;</span><br><span class="line">            query_string++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//sprintf 将url写成path格式，放到htdocs的缓存区，</span></span><br><span class="line">    <span class="built_in">sprintf</span>(path, <span class="string">"htdocs%s"</span>, url);</span><br><span class="line">    <span class="keyword">if</span> (path[<span class="built_in">strlen</span>(path) - <span class="number">1</span>] == <span class="string">'/'</span>)</span><br><span class="line">        <span class="comment">//strcat 在path添加"index.html"</span></span><br><span class="line">        <span class="built_in">strcat</span>(path, <span class="string">"index.html"</span>);</span><br><span class="line">    <span class="comment">//如果文件路径不在</span></span><br><span class="line">    <span class="keyword">if</span> (stat(path, &amp;st) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//读取标题</span></span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>, buf))  <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">            numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        not_found(client);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件存在</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//文件目录路径一致</span></span><br><span class="line">        <span class="keyword">if</span> ((st.st_mode &amp; S_IFMT) == S_IFDIR)</span><br><span class="line">            <span class="built_in">strcat</span>(path, <span class="string">"/index.html"</span>);</span><br><span class="line">        <span class="comment">//具有可执行权限</span></span><br><span class="line">        <span class="keyword">if</span> ((st.st_mode &amp; S_IXUSR) ||</span><br><span class="line">                (st.st_mode &amp; S_IXGRP) ||</span><br><span class="line">                (st.st_mode &amp; S_IXOTH)    )</span><br><span class="line">            cgi = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//cgi=0,返回文件；cgi=1，执行execute_cgi程序</span></span><br><span class="line">        <span class="keyword">if</span> (!cgi)</span><br><span class="line">            serve_file(client, path);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            execute_cgi(client, path, method, query_string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用到的知识-2"><a href="#用到的知识-2" class="headerlink" title="用到的知识"></a>用到的知识</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">S_IFDIR <span class="number">0040000</span> 目录</span><br><span class="line">S_IFMT <span class="number">0170000</span> 文件类型的位遮罩</span><br><span class="line">S_IXUSR (S_IEXEC) <span class="number">0010</span>s具可执行权限</span><br><span class="line">S_IXOTH <span class="number">00001</span> 其他用户具可执行权限上述的文件类型在 POSIX 中定义了检查这些类型的宏定义</span><br></pre></td></tr></table></figure>



<h2 id="execute-cgi函数"><a href="#execute-cgi函数" class="headerlink" title="execute_cgi函数"></a>execute_cgi函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute_cgi</span><span class="params">(<span class="keyword">int</span> client, <span class="keyword">const</span> <span class="keyword">char</span> *path,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *method, <span class="keyword">const</span> <span class="keyword">char</span> *query_string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> cgi_output[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> cgi_input[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> numchars = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> content_length = <span class="number">-1</span>;</span><br><span class="line">	buf[<span class="number">0</span>] = <span class="string">'A'</span>; buf[<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">// GET </span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>, buf))  <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">            numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (strcasecmp(method, <span class="string">"POST"</span>) == <span class="number">0</span>) <span class="comment">/*POST*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>, buf))</span><br><span class="line">        &#123;</span><br><span class="line">            buf[<span class="number">15</span>] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="comment">//从post里找到Cotent-Length，并放入content_length</span></span><br><span class="line">            <span class="keyword">if</span> (strcasecmp(buf, <span class="string">"Content-Length:"</span>) == <span class="number">0</span>)</span><br><span class="line">                content_length = atoi(&amp;(buf[<span class="number">16</span>]));<span class="comment">//atoi函数将数转换成整型数   </span></span><br><span class="line">            numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找不到content_lengt</span></span><br><span class="line">        <span class="keyword">if</span> (content_length == <span class="number">-1</span>) &#123;</span><br><span class="line">            bad_request(client);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">/*HEAD or other*/</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(cgi_output) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pipe(cgi_input) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="comment">//前面2个错误没有发生，建立input和output管道成功</span></span><br><span class="line">    <span class="keyword">if</span> ( (pid = fork()) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fork创造input和output子进程 </span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 200 OK\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//pid==0即在子进程里运行，子进程用来连接 </span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)  <span class="comment">/* child: CGI script */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> meth_env[<span class="number">255</span>];</span><br><span class="line">        <span class="keyword">char</span> query_env[<span class="number">255</span>];</span><br><span class="line">        <span class="keyword">char</span> length_env[<span class="number">255</span>];</span><br><span class="line">		<span class="comment">//以下4句对应知识点2</span></span><br><span class="line">        dup2(cgi_output[<span class="number">1</span>], STDOUT);</span><br><span class="line">        dup2(cgi_input[<span class="number">0</span>], STDIN);</span><br><span class="line">        <span class="built_in">close</span>(cgi_output[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(cgi_input[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sprintf</span>(meth_env, <span class="string">"REQUEST_METHOD=%s"</span>, method);</span><br><span class="line">        putenv(meth_env);</span><br><span class="line">        <span class="comment">//cgi的环境配置，分别对应GET和POST</span></span><br><span class="line">        <span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(query_env, <span class="string">"QUERY_STRING=%s"</span>, query_string);</span><br><span class="line">            putenv(query_env);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;   <span class="comment">/* POST */</span></span><br><span class="line">            <span class="built_in">sprintf</span>(length_env, <span class="string">"CONTENT_LENGTH=%d"</span>, content_length);</span><br><span class="line">            putenv(length_env);</span><br><span class="line">        &#125;</span><br><span class="line">        execl(path, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//父进程用来接受和发送</span></span><br><span class="line">    <span class="keyword">else</span> &#123;    <span class="comment">/* parent */</span></span><br><span class="line">        <span class="built_in">close</span>(cgi_output[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">close</span>(cgi_input[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (strcasecmp(method, <span class="string">"POST"</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; content_length; i++) &#123;</span><br><span class="line">                <span class="comment">//得到post请求数据，写到input管道中，供子进程使用</span></span><br><span class="line">                recv(client, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">write</span>(cgi_input[<span class="number">1</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//从output管道读到子进程处理后的信息，然后send出去</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">read</span>(cgi_output[<span class="number">0</span>], &amp;c, <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">            send(client, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//完成操作后关闭管道</span></span><br><span class="line">        <span class="built_in">close</span>(cgi_output[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(cgi_input[<span class="number">1</span>]);</span><br><span class="line">        waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用到的知识-3"><a href="#用到的知识-3" class="headerlink" title="用到的知识"></a>用到的知识</h3><h4 id="知识点1"><a href="#知识点1" class="headerlink" title="知识点1"></a>知识点1</h4><p>​        HTTP请求中的Content-Length是指文件长度。Content-Length：这个字符串一共长为15位，所以在16位时结束， 即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buf[15] &#x3D; &#39;\0&#39;</span><br></pre></td></tr></table></figure>

<h4 id="知识点2"><a href="#知识点2" class="headerlink" title="知识点2"></a>知识点2</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dup2(cgi_output[<span class="number">1</span>], STDOUT);</span><br><span class="line"> dup2(cgi_input[<span class="number">0</span>], STDIN);</span><br><span class="line"> <span class="built_in">close</span>(cgi_output[<span class="number">0</span>]);</span><br><span class="line"> <span class="built_in">close</span>(cgi_input[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>



<p><img src="Tinyhttpd%E7%9A%84%E5%AD%A6%E4%B9%A0/before.jpg" alt=""></p>
<p><img src="Tinyhttpd%E7%9A%84%E5%AD%A6%E4%B9%A0/after.jpg" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>markdown学习</title>
    <url>/2020/01/13/%E6%97%A5%E5%BF%97/markdown%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="markdown新手入门-typora"><a href="#markdown新手入门-typora" class="headerlink" title="markdown新手入门 (typora)"></a>markdown新手入门 (typora)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        本次的学习基本上跟B站上的一位作者学习，他的<a href="ttps://www.bilibili.com/video/av77142116">视频</a>贴在这里，感谢这位up主。下面就是本人的学习，以后可以用作查看。</p>
<a id="more"></a>



<h2 id="1-代码块："><a href="#1-代码块：" class="headerlink" title="1.代码块："></a>1.代码块：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码块语法</span></span><br><span class="line">​```java</span><br><span class="line">    </span><br><span class="line">​```c</span><br></pre></td></tr></table></figure>

<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">liejia(&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i；</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&gt;n;i++)</span><br><span class="line">        s++=i;</span><br><span class="line">    <span class="keyword">return</span> s；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-标题："><a href="#2-标题：" class="headerlink" title="2.标题："></a>2.标题：</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标题语法</span></span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="3-字体"><a href="#3-字体" class="headerlink" title="3.字体"></a>3.字体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加粗</span></span><br><span class="line">**只求心花终于盛开**</span><br><span class="line"><span class="comment">//代码高亮显示</span></span><br><span class="line">==就没有别的期待==    </span><br><span class="line"><span class="comment">//删除线</span></span><br><span class="line">~~等梦完醒来~~    </span><br><span class="line"><span class="comment">//斜体</span></span><br><span class="line">*再去收拾残骸*</span><br></pre></td></tr></table></figure>

<h3 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h3><p><strong>只求心花终于盛开</strong></p>
<p>==就没有别的期待==    </p>
<p><del>等梦完醒来</del>    </p>
<p><em>再去收拾残骸</em> </p>
<h2 id="4-引用"><a href="#4-引用" class="headerlink" title="4.引用"></a>4.引用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用语法</span></span><br><span class="line">&gt;作者</span><br><span class="line">&gt;&gt;作者</span><br><span class="line">&gt;&gt;&gt;作者</span><br></pre></td></tr></table></figure>

<h3 id="演示-3"><a href="#演示-3" class="headerlink" title="演示"></a>演示</h3><blockquote>
<p>作者</p>
<blockquote>
<p>作者</p>
<blockquote>
<p>作者 </p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="5-分割线"><a href="#5-分割线" class="headerlink" title="5.分割线"></a>5.分割线</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分割线</span></span><br><span class="line">---</span><br><span class="line">    </span><br><span class="line"><span class="comment">//分割线2</span></span><br><span class="line">***</span><br></pre></td></tr></table></figure>

<h3 id="演示-4"><a href="#演示-4" class="headerlink" title="演示"></a>演示</h3><hr>
<hr>
<h2 id="6-图片插入"><a href="#6-图片插入" class="headerlink" title="6.图片插入"></a>6.图片插入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在线图片/本地图片</span></span><br><span class="line">![图片名称](https:<span class="comment">//ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=385691980,1109875715&amp;fm=26&amp;gp=0.jpg) --图片路径(图片来源百度)</span></span><br><span class="line"> </span><br><span class="line">        </span><br><span class="line">![图片名称](C:\Users\Administrator\Pictures\Camera Roll\无标题.png)  --图片路径(图片来源火萤桌面)</span><br></pre></td></tr></table></figure>

<h3 id="演示-5"><a href="#演示-5" class="headerlink" title="演示"></a>演示</h3><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=385691980,1109875715&fm=26&gp=0.jpg" alt="图片名称"></p>
<p>![图片名称](C:\Users\Administrator\Pictures\Camera Roll\无标题.png)</p>
<h2 id="7-超链接"><a href="#7-超链接" class="headerlink" title="7.超链接"></a>7.超链接</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超链接语法</span></span><br><span class="line">[超链接名字](www.baidu.com)</span><br></pre></td></tr></table></figure>

<h3 id="演示-6"><a href="#演示-6" class="headerlink" title="演示"></a>演示</h3><p><a href="www.baidu.com">百度</a></p>
<h2 id="8-列表语法"><a href="#8-列表语法" class="headerlink" title="8.列表语法"></a>8.列表语法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无序列表</span></span><br><span class="line">- 无序目录<span class="number">1</span></span><br><span class="line">- 无序目录<span class="number">2</span> </span><br><span class="line">- 无序目录<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有序列表</span></span><br><span class="line"><span class="number">1</span>. 有序列表</span><br><span class="line"><span class="number">2</span>. 有序列表</span><br><span class="line"><span class="number">3</span>. 有序列表</span><br></pre></td></tr></table></figure>

<h2 id="演示-7"><a href="#演示-7" class="headerlink" title="演示"></a>演示</h2><ul>
<li>无序目录1</li>
<li>无序目录2 </li>
<li>无序目录3</li>
</ul>
<ol>
<li><p>有序列表</p>
</li>
<li><p>有序列表</p>
</li>
<li><p>有序列表</p>
</li>
</ol>
<h2 id="9-表格"><a href="#9-表格" class="headerlink" title="9. 表格"></a>9. 表格</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">鼠标右键</span><br></pre></td></tr></table></figure>

<h3 id="演示-8"><a href="#演示-8" class="headerlink" title="演示"></a>演示</h3><table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>9</td>
<td>10</td>
<td>11</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>博客日志</title>
    <url>/2020/01/13/%E6%97%A5%E5%BF%97/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="1-0-搭建博客"><a href="#1-0-搭建博客" class="headerlink" title="1.0 搭建博客"></a>1.0 搭建博客</h2><h3 id="基于node与git环境搭建博客"><a href="#基于node与git环境搭建博客" class="headerlink" title="基于node与git环境搭建博客"></a>基于node与git环境搭建博客</h3><p>​       下载nodejs和git，在全局环境下安装cnpm和hexo。如果把nodejs和git下在了D盘，会导致了使用hexo init（初始化）时出现了两种不同错误，在csdn上查到问题的解决办法。现在已经搭建完成，未记录错误。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https:<span class="comment">//registry npm taobao ory       //利用淘宝镜像下载cnpm，-g代表全局</span></span><br></pre></td></tr></table></figure>

<hr>
<p>这里把一些可能用到的代码放在下面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hexo g  <span class="comment">//生成</span></span><br><span class="line">hexo s    <span class="comment">//在本地构建</span></span><br><span class="line">hexo d   <span class="comment">// 传到远端网络</span></span><br></pre></td></tr></table></figure>

<h2 id="2-0-主题更换"><a href="#2-0-主题更换" class="headerlink" title="2.0 主题更换"></a>2.0 主题更换</h2><p>​        本主题为<a href="https://shen-yu.gitee.io/2019/ayer/" target="_blank" rel="noopener">Ayer</a>,依照该4中文指示开始复制，下面的内容主要为我遇到的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;<span class="comment">//如果文章太长，在markdown下加这行代码</span></span><br></pre></td></tr></table></figure>

<p>​        </p>
<p>​        出现错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure>

<p>​        由于之前对_config.yml编辑时使得deploy出错，需要重新安装。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>



<hr>
]]></content>
  </entry>
</search>
